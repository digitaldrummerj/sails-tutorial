<!DOCTYPE html>
<html lang="en">

<head>
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Sails Tutorial</title>


	<meta charset="utf-8">
	<meta name="description" content="Sails Workshop">
	<meta name="author" content="Justin James">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="css/style.css" rel="stylesheet">
</head>

<body>

	<div id="tutorial-container">
		<div id="header">
			<a href="#" class="menu header-btn" id="toggle-toc"></a>
			<h1>Sails Tutorial</h1>
			<a href="https://github.com/digitaldrummerj/sails-tutorial" class="github header-btn"></a>
		</div>
		<div id="tutorial-content-container">

			<div id="toc">
				<div class="toc-heading">Table of Contents</div>
				<div id="toc-padding"></div>
			</div>
			<div id="book">
				<div class="chapter">
					<h2 id="introduction">Introduction</h2>
<p>Welcome to the Sails Tutorial.  </p>
<p>In this tutorial, you&#39;ll learn how to build a Sails Api. Throughout the tutorial, you will be building a todo api.  </p>
<h3 id="materials">Materials</h3>
<ul>
<li><a href="https://www.slideshare.net/digitaldrummerj/rapid-api-development-with-node-and-sails">Presentation</a></li>
</ul>

				</div>
				<hr>
				<div class="chapter">
					<h2 id="getting-up-and-running">Getting up and running</h2>
<p>We will utilize a number of tools in our Sails development to allow us to create, debug, and deploy our application.  We will be utilizing the following tools:</p>
<ul>
<li>Platforms: Windows, Mac, or Linux computer</li>
<li>Software:<ul>
<li>git command line</li>
<li>Node 6.x</li>
<li>sails</li>
<li>Postman    </li>
<li>Visual Studio Code</li>
</ul>
</li>
</ul>
<p>Below are all of the steps required to install and configure the tools.  </p>
<h3 id="windows-showing-file-extensions">Windows Showing File Extensions</h3>
<div class="alert alert-danger" role="alert">
<strong>Windows Only</strong>
</div>

<p><strong>Non-Windows users can <a href="#chapter2.4">skip to next section</a></strong></p>
<p>By default Windows is set to not show file extensions for known files which causes files such as .gitconfig and .npmrc to show up as just a period with no file extensions.  To fix this we need to set Windows Explorer to show file extensions.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Turn On Windows Showing File Extensions
</h4>

<ol>
<li>Open Windows Explorer</li>
<li><p>Click on the View Tab and select Options</p>
<p> <img src="images/chapter1/windows-explorer-ribbon.png"></p>
</li>
<li><p>Click on the View Tab</p>
</li>
<li>Uncheck the &quot;Hide extensions for known file types&quot;</li>
<li><p>Click Ok</p>
<p> <img src="images/chapter1/windows-explorer-view-options.png"></p>
</li>
</ol>
<div class="exercise-end"></div>

<h3 id="node-js">Node.js</h3>
<p>NodeJS is used to power the Sails CLI as well as install all of our dependencies.  The Sails CLI will work with Node 4.x+.  Since I am using Angular for my UI which requires Node version 6.9+, we are going to install the latest LTS version of Node which as of this writing is 6.11.0..</p>
<h4 class="exercise-start">
<b>Exervise</b>: Install Node
</h4>

<ol>
<li>Download the latest stable version (LTS) of <a href="http://nodejs.org">NodeJS</a>.  </li>
<li>Run the installer and accept all defaults.</li>
<li><p>To validate that Node installed successfully, open a new command prompt and run the following command:</p>
<pre><code class="lang-bash">node -v
</code></pre>
</li>
</ol>
<div class="exercise-end"></div>

<h3 id="sails-js">Sails.js</h3>
<h4 class="exercise-start">
    <b>Exercise:</b>: Install Sails Globally
</h4>

<ol>
<li>Open a terminal window if it&#39;s not already open</li>
<li><p>Execute the following command to install Sails:</p>
<pre><code class="lang-bash"> npm install -g sails
</code></pre>
</li>
<li><p>Validate that Sails installed successfully by running the following command:</p>
<pre><code class="lang-bash"> sails -v
</code></pre>
<blockquote>
<p>0.12.13 as of this writing</p>
</blockquote>
</li>
</ol>
<div class="exercise-end"></div>

<h3 id="postman">Postman</h3>
<p>Postman is a useful utility for testing REST apis without having to create a UI.</p>
<ol>
<li>You can download it from <a href="https://www.getpostman.com/apps">https://www.getpostman.com/apps</a></li>
<li>Once the download finishes, launch the installer and accept all of the defaults</li>
</ol>
<h3 id="visual-studio-code">Visual Studio Code</h3>
<p>Visual Studio Code is Microsoft lightweight cross platform IDE.  You could use any editor that you would like to developer our  Sails but only Visual Studio Code has been tested against</p>
<ol>
<li>Download Visual Studio Code at <a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a></li>
<li>Once the download finishes, launch the installer except all of the defaults</li>
</ol>

				</div>
				<hr>
				<div class="chapter">
					<h2 id="creating-sails-api">Creating Sails Api</h2>
<p>We will utilize the Sails CLI to generate a project for us to developer our API with.  By default Sails comes with a view engine unless you tell it otherwise.  When we create our project we will only  be creating an API project and will not include the view engine as part of the project. </p>
<h3 id="create-project">Create Project</h3>
<h4 class="exercise-start">
    <b>Exercise</b>: Create Sails Project
</h4>

<p>To generate the project we need to run the intc gen-ui command.</p>
<ol>
<li>Open a command prompt or terminal</li>
<li>Navigate to where you store your project code (I store mine at c:\projects)</li>
<li><p>Run the following command to generate the project.  </p>
<pre><code> sails new sails-tutorial --no-linker --no-frontend
</code></pre> <div class="alert alert-info" role="alert">This will create a new Sails project called sails-tutorial and install the npm dependencies</div>

</li>
</ol>
<div class="exercise-end"></div>

<h3 id="opening-project-in-visual-studio-code">Opening Project in Visual Studio Code</h3>
<h4 class="exercise-start">
  <b>Exercise</b>: Open Project
</h4>

<ol>
<li>Open Visual Studio Code</li>
<li>Click File -&gt; Open Folder...</li>
<li>Navigate to where you created the sails-tutorial folder and click Select Folder </li>
<li>Your project should now be opened in Visual Studio Code</li>
</ol>
<div class="exercise-end"></div>

<h3 id="navigating-around-visual-studio-code">Navigating around Visual Studio Code</h3>
<p>Being able to effectively use your editor is key to being a super productive developer.  With Visual Studio Code, there are several shortcut keys that will help you out.</p>
<table>
<thead>
<tr>
<th>Purpose</th>
<th>Key</th>
</tr>
</thead>
<tbody>
<tr>
<td>Integrated Terminal</td>
<td>ctrl+`</td>
</tr>
<tr>
<td>Open File</td>
<td>ctrl+p</td>
</tr>
<tr>
<td>Switch Between Files</td>
<td>ctrl+tab</td>
</tr>
<tr>
<td>Switch Between Files Reverse</td>
<td>ctrl+shift+tab</td>
</tr>
<tr>
<td>Hide Side Menu</td>
<td>ctrl+b</td>
</tr>
<tr>
<td>Toggle Word Wrap for File</td>
<td>alt+z</td>
</tr>
<tr>
<td>Format Document</td>
<td>ctrl+alt+f</td>
</tr>
</tbody>
</table>
<div class="alert alert-info" role="alert"> I also split my screen in half with the tutorial on one side and the editor on the other side.  On Windows you can do this by using the win key + left arrow for the one you want on the left and then select the other for the right when windows prompts you.  You can also use win key + right arrow to make a Windows use half the screen on the right.</div>

<h3 id="visual-studio-settings">Visual Studio Settings</h3>
<p>There are 2 types of Settings in Visual Studio Code:  User and Workspace.  User settings apply to all instances of Visual Studio Code.  Workspace settings apply to the currently folder that you have open and are stored in a .vscode directory within the folder.</p>
<p>There are a few settings that I like to change within Visual Studio Code.  </p>
<ol>
<li>Turn off the mini map in the upper right corder that I find distracting</li>
<li>Turn off telemetry and crash reporter</li>
<li>Turn on word wrap</li>
<li>Turn on indent guides</li>
</ol>
<h4 class="exercise-start">
  <b>Exercise</b>: Updating Settings
</h4>

<ol>
<li>Go under the Preferences -&gt; Settings (File -&gt; Preferences -&gt; Settings on Windows) and add the following setting to the &quot;User Settings&quot; tab</li>
</ol>
<pre><code class="lang-bash">{
    &quot;telemetry.enableTelemetry&quot;: false,
    &quot;telemetry.enableCrashReporter&quot;: false,
    &quot;editor.minimap.enabled&quot;: false,
    &quot;editor.wordWrap&quot;: &quot;on&quot;,
    &quot;editor.wrappingIndent&quot;: &quot;same&quot;,
    &quot;editor.renderIndentGuides&quot;: true,
}
</code></pre>
<div class="exercise-end"></div>



				</div>
				<hr>
				<div class="chapter">
					<h2 id="sails-project-layout">Sails Project Layout</h2>
<h3 id="api-controllers">API Controllers</h3>
<blockquote>
<p>api/controllers</p>
</blockquote>
<p>Controllers are defined in the api/controllers/ folder. You can put any files you like in that folder, but in order for them to be loaded by Sails as controllers, a file must end in Controller.js. </p>
<p>Controllers (the C in MVC) are the principal objects in your Sails application that are responsible for responding to requests from a web browser, mobile application or any other system capable of communicating with a server. For many applications, the controllers will contain the bulk of your projectâ€™s business logic.</p>
<p>Controllers are comprised of a set of methods called actions. Actions are bound to routes, so that when a client requests the route, the action is executed to perform some business logic and send a response. </p>
<p>Using the command line you can generate a controller and model by using the sails generate command api</p>
<pre><code class="lang-bash">sails generate api &lt;API Name&gt;
</code></pre>
<p>Get more details on Controllers at <a href="http://sailsjs.org/documentation/concepts/controllers">http://sailsjs.org/documentation/concepts/controllers</a></p>
<h3 id="api-models">API Models</h3>
<blockquote>
<p>directory: api/models</p>
</blockquote>
<p>Models are defined in the api/models/ folder.</p>
<p>A model represents a collection of structured data, usually corresponding to a single table or collection in a database. </p>
<p> There are many built-in methods available on models, the most important of which are the query methods: <a href="http://sailsjs.org/documentation/reference/waterline/models/find.html">find</a>, <a href="http://sailsjs.org/documentation/reference/waterline/models/create.html">create</a>, <a href="http://sailsjs.org/documentation/reference/waterline/models/update.html">update</a>, and <a href="http://sailsjs.org/documentation/reference/waterline/models/destroy.html">destroy</a>. These methods are asynchronous - under the covers, Waterline has to send a query to the database and wait for a response.</p>
<p>Get more details on Models at <a href="http://sailsjs.org/documentation/concepts/models-and-orm/models">http://sailsjs.org/documentation/concepts/models-and-orm/models</a></p>
<h3 id="api-policies">API Policies</h3>
<blockquote>
<p>directory: api/policies</p>
</blockquote>
<p>Policies in Sails are used for authorization and access control.  Basically they let you allow or deny access to your controllers down to a fine level of granularity. </p>
<p>Policies can be used for anything: HTTP BasicAuth, 3rd party single-sign-on, OAuth 2.0, or your own custom authorization/authentication scheme.</p>
<p>Policies are files defined in the api/policies folder in your Sails app. Each policy file should contain a single function and ideally should just check one thing.</p>
<p>Policies are really just Connect/Express middleware functions which run before your controllers. They are designed to be chained together.  </p>
<p>See <a href="http://sailsjs.com/documentation/concepts/policies">Policies Docs</a></p>
<h3 id="api-responses">API Responses</h3>
<blockquote>
<p>directory: api/responses</p>
</blockquote>
<p>Sails allows for customizable server responses. Sails comes with a handful of the most common response types by default that are found in the /api/responses directory of our project. To customize these, simply edit the appropriate .js file.</p>
<p>Any .js script saved in the /api/responses folder will be executed by calling res.[responseName] in your controller. For example, /api/responses/serverError.js can be executed with a call to res.serverError(errors). The request and response objects are available inside the response script as this.req and this.res; this allows the actual response function to take arbitrary parameters (like serverError&#39;s errors parameter).</p>
<p>See <a href="http://sailsjs.com/documentation/concepts/custom-responses">Response Docs</a></p>
<h3 id="api-services">API Services</h3>
<blockquote>
<p>directory: api/services</p>
</blockquote>
<p>Services are defined in the api\services folder.</p>
<p>Services are stateless libraries of functions (called helpers) that you can use from anywhere in your Sails app.  They are globalized and you don&#39;t have to use require() to access them.  </p>
<p>See <a href="http://sailsjs.org/documentation/concepts/services">Services Docs</a></p>
<h3 id="configuration-overview">Configuration Overview</h3>
<p>Configuration files are defined in the config folder.</p>
<p>While Sails dutifully adheres to the philosophy of convention-over-configuration, it is important to understand how to customize those handy defaults from time to time. For almost every convention in Sails, there is an accompanying set of configuration options that allow you to adjust or override things to fit your needs.</p>
<p>Sails apps can be configured programmatically, by specifying environment variables or command-line arguments, by changing the local or global .sailsrc files, or (most commonly) using the boilerplate configuration files conventionally located in the config/ folder of new projects. The authoritative, merged-together configuration used in your app is available at runtime on the sails global as sails.config.</p>
<p>Get more details on Configuration at <a href="http://sailsjs.org/documentation/concepts/configuration">http://sailsjs.org/documentation/concepts/configuration</a></p>
<h3 id="configurations-environment">Configurations Environment</h3>
<blockquote>
<p>file: config/env/development.js and config/env/production.js</p>
</blockquote>
<h3 id="configurations-connections">Configurations Connections</h3>
<blockquote>
<p>file: config/connections.js</p>
</blockquote>
<p>Storage connections are configured in the connections.js file. You can also specify connections in your config/local.js or environment-specific config files and reference them in the connections.js file.</p>
<p>See <a href="http://sailsjs.com/documentation/reference/configuration/sails-config-connections">Docs</a></p>
<h3 id="configurations-cors">Configurations CORS</h3>
<blockquote>
<p>file: config/cors.js</p>
</blockquote>
<p>CORS specifies how HTTP requests to your app originating from foreign domains should be treated. It is primarily used to allow third-party sites to make AJAX requests to your app, which are normally blocked by browsers following the same-origin policy.</p>
<p>See <a href="http://sailsjs.com/documentation/reference/configuration/sails-config-cors">Docs</a></p>
<h3 id="configurations-locals">Configurations Locals</h3>
<blockquote>
<p>file: config/local.js</p>
</blockquote>
<p>The config/local.js file is used to configure a Sails app for your local environment. The settings in this file take precedence over all other config files except .sailsrc. Since they&#39;re intended only for local use, <strong>they should not be put under version control</strong> . Use local.js to store local database settings, change the port used when lifting an app on your computer, etc.</p>
<h3 id="configurations-models">Configurations Models</h3>
<blockquote>
<p>file: config/models.js</p>
</blockquote>
<p>Your default project-wide model settings. We will be using it to store your migrate strategy and the default connection to use for your models.  </p>
<p>You can also override the settings on a per-model basis.</p>
<p>See <a href="http://sailsjs.com/documentation/reference/configuration/sails-config-models">Docs</a></p>
<h3 id="configurations-policies">Configurations Policies</h3>
<blockquote>
<p>file: config/policies.js</p>
</blockquote>
<p>Your applications ACL (access control list) to apply to each controller and route.  Policies can be chained together using the array syntax.</p>
<p>See <a href="http://sailsjs.com/documentation/reference/configuration/sails-config-policies">Docs</a></p>
<h3 id="configurations-routes">Configurations Routes</h3>
<blockquote>
<p>file: config/routes.js</p>
</blockquote>
<p>Configuration for your routes.  For a given route you will configure: REST verb, url, controller and function that a route maps to.</p>
<p>See <a href="http://sailsjs.com/documentation/reference/configuration/sails-config-routes">Docs</a></p>
<h3 id="configurations-session">Configurations Session</h3>
<blockquote>
<p>file: config/session.js</p>
</blockquote>
<p>Configuration for Sails built-in session store.  You can add/get information from session by using req.session.  </p>
<p>See <a href="http://sailsjs.com/documentation/reference/configuration/sails-config-session">Docs</a></p>

				</div>
				<hr>
				<div class="chapter">
					<h2 id="generating-api">Generating Api</h2>
<p>Now that we have generated our project, before we can use it, we need to generate an Api.  Our Todo API will have two APIs:  User and Todo.  We will use the Sails CLI to generate the APIs.  </p>
<p>When you generate a new api it will create a model and controller for the API.  A model describes the data store fields with attributes such as type, required, unique, and defaultsTo.  The controller will contain our functions that are related to the model.  </p>
<p>Out of the box, Sails wires up all of the REST verbs (GET, POST, PUT, DELETE) for us and saves the data to a schema-less JSON file as the data store.  This means that immediately after running the generate command we can use the API without having to write any code. </p>
<h3 id="generating-user-api">Generating User API</h3>
<h4 class="exercise-start">
  <b>Exercise</b>: Generating User API
</h4>

<ol>
<li>Visual Studio Code has a built-in terminal that we can use to run our commands.  Open up the integrated terminal in Visual Studio Code  by using ctrl+` or view menu -&gt; Integrated Terminal</li>
<li><p>Run the following command to create the user API</p>
<pre><code class="lang-bash"> sails generate api user
</code></pre>
</li>
<li><p>This will create 2 files for us:</p>
<ul>
<li>api\controllers\UserController.js</li>
<li>api\models\User.js</li>
</ul>
</li>
</ol>
<div class="exercise-end"></div>

<h3 id="generating-todo-api">Generating Todo Api</h3>
<h4 class="exercise-start">
  <b>Exercise</b>: Generating Todo API
</h4>

<ol>
<li><p>In the Visual Studio Code integrated terminal (ctrl+` or view menu -&gt; Integrated Terminal), run the  following command to create the user API</p>
<pre><code class="lang-bash"> sails generate api todo
</code></pre>
</li>
<li><p>This will create 2 files for us:</p>
<ul>
<li>api\controllers\TodoController.js</li>
<li>api\models\Todo.js</li>
</ul>
</li>
</ol>
<div class="exercise-end"></div>

<h3 id="running-api">Running Api</h3>
<h4 class="exercise-start">
    <b>Exercise</b>: Starting Api
</h4>

<ol>
<li><p>In the Visual Studio Code integrated  terminal run the following command to start our API</p>
<pre><code class="lang-bash"> sails lift
</code></pre>
<p> <img src="images/db-migrate-question.png" alt="sails lift output"></p>
 <div class="alert alert-danger" role="alert">You will notice that you are prompted with a big long question about database migration strategy to use.  Sails does not make any assumptions on how we want it to deal with database migrations as the models are updated.  Out of the box Sails uses a schema-less JSON file as the data store.  This is what allows us to immediately started working with our API.  Until we set the database migration strategy to use, we will be prompted to select one when we run sails lift.</div>
</li>
<li><p>When prompted for the migration strategy, type 2 and press enter</p>
<p> <img src="images/db-migrate-answer.png" alt="sails lift started">    </p>
 <div class="alert alert-info" role="alert">You will see that a message shows up that says &quot;Temporarily using sails.config.models.migrate=&quot;alert&quot;...&quot;</div>
</li>
<li><p>The API is now started up and we are ready to do some testing with Postman</p>
</li>
</ol>
<div class="exercise-end"></div>

<h3 id="get-data">Get Data</h3>
<h4 class="exercise-start">
    <b>Exercise</b>: Get Data
</h4>


<ol>
<li>Open up Postman</li>
<li>Set the VERB to GET (<em>step 1</em>)</li>
<li><p>Set the url to <a href="http://localhost:1337/user">http://localhost:1337/user</a> (<em>step 2</em>)</p>
<pre><code class="lang-bash"> http://localhost:1337/user
</code></pre>
</li>
<li><p>Click the Send button (<em>step 3</em>)</p>
</li>
<li>Right now you should have gotten an empty array as we have not added any data yet (<em>step 4</em>)</li>
<li>You should have also gotten a status code of 200 (<em>step 5</em>)</li>
</ol>
<p><img src="images/postman-user-get-blank.png" alt="Postman get"></p>
<div class="exercise-end"></div>

<h3 id="insert-data">Insert Data</h3>
<h4 class="exercise-start">
    <b>Exercise</b>: Insert Data
</h4>

<p>We can insert data using the REST verb POST.</p>
<ol>
<li>In Postman, change the VERB to POST (<em>step 1</em>)</li>
<li><p>Leave the url set to <a href="http://localhost:1337/user">http://localhost:1337/user</a> (<em>step 2</em>)</p>
<pre><code class="lang-bash"> http://localhost:1337/user
</code></pre>
</li>
<li><p>Click on the Body tab (<em>step 3</em>)</p>
</li>
<li>Click raw radio button (<em>step 4</em>)</li>
<li>Change the type dropdown from &quot;Text&quot; to &quot;application/json&quot; (<em>step 5</em>)</li>
<li><p>Set the request body to the following JSON (<em>step 6</em>)</p>
<pre><code class="lang-json"> {
     &quot;email&quot;: &quot;foo@foo.com&quot;,
     &quot;password&quot;: &quot;123456&quot;
 }
</code></pre>
</li>
<li><p>Click the Send button (<em>step 7</em>)</p>
</li>
<li><p>You will get an output similar to the following. (<em>step 8 </em>)</p>
<pre><code class="lang-json"> {
     &quot;email&quot;: &quot;foo@foo.com&quot;,
     &quot;password&quot;: &quot;123456&quot;,
     &quot;createdAt&quot;: &quot;2017-07-23T22:09:29.601Z&quot;,
     &quot;updatedAt&quot;: &quot;2017-07-23T22:09:29.601Z&quot;,
     &quot;id&quot;: 1
 }
</code></pre>
</li>
<li><p>You should also have a status code of 201 (<em>step 9</em>)</p>
</li>
</ol>
<p><img src="images/postman-user-post.png" alt="Postman POST"></p>
<div class="exercise-end"></div>

<h3 id="update-data">Update Data</h3>
<h4 class="exercise-start">
    <b>Exercise</b>: Update Data
</h4>

<p>We can update data using the REST verb PUT.</p>
<ol>
<li>In Postman VERB to PUT (<em>step 1</em>)</li>
<li>Change the url to <a href="http://localhost:1337/user/1">http://localhost:1337/user/1</a> (<em>step 2</em>)</li>
<li>Click on the Body tab (<em>step 3</em>)</li>
<li>Click raw radio button (<em>step 4</em>)</li>
<li>Change the type dropdown from &quot;Text&quot; to &quot;application/json&quot; (<em>step 5</em>)</li>
<li><p>Set the request body to the following JSON (<em>step 6</em>)</p>
<pre><code class="lang-json"> {
     &quot;email&quot;: &quot;foo1@foo.com&quot;,
     &quot;password&quot;: &quot;1234567&quot;
 }
</code></pre>
</li>
<li><p>Click the Send button (<em>step 7</em>)</p>
</li>
<li><p>You will get an output similar to the following. (<em>step 8</em>)</p>
<pre><code class="lang-json"> {
     &quot;email&quot;: &quot;foo1@foo.com&quot;,
     &quot;password&quot;: &quot;1234567&quot;,
     &quot;createdAt&quot;: &quot;2017-07-23T22:09:29.601Z&quot;,
     &quot;updatedAt&quot;: &quot;2017-07-23T22:09:29.601Z&quot;,
     &quot;id&quot;: 1
 }
</code></pre>
</li>
<li><p>You should also have a status code of 201 (<em>step 9</em>)</p>
</li>
</ol>
<p><img src="images/postman-user-put.png" alt="Postman PUT"></p>
<div class="alert alert-info" role="alert">Right now update returns the record that we just deleted.  In the next Sails release it will not return any data.</div>

<div class="exercise-end"></div>

<h3 id="delete-data">Delete Data</h3>
<h4 class="exercise-start">
    <b>Exercise</b>: Delete Data
</h4>

<p>We can update data using the REST verb DELETE.</p>
<ol>
<li>In Postman VERB to DELETE (<em>step 1</em>)</li>
<li>Change the url to <a href="http://localhost:1337/user/1">http://localhost:1337/user/1</a> (<em>step 2</em>)</li>
<li>Click the Send button (<em>step 3</em>)</li>
<li><p>You will get an output similar to the following.  (<em>step 4</em>)</p>
<pre><code class="lang-json"> {
     &quot;email&quot;: &quot;foo1@foo.com&quot;,
     &quot;password&quot;: &quot;1234567&quot;,
     &quot;createdAt&quot;: &quot;2017-07-23T22:09:29.601Z&quot;,
     &quot;updatedAt&quot;: &quot;2017-07-23T22:09:29.601Z&quot;,
     &quot;id&quot;: 1
 }
</code></pre>
</li>
<li><p>You should also have a status code of 200 (<em>step 5</em>)</p>
</li>
</ol>
<p><img src="images/postman-user-delete.png" alt="Postman PUT"></p>
<div class="alert alert-info" role="alert">Right now delete returns the record that we just deleted.  In the next Sails release it will not return any data.</div>

<div class="exercise-end"></div>


				</div>
				<hr>
				<div class="chapter">
					<h2 id="model-migration-strategy">Model Migration Strategy</h2>
<p>Right now everytime you start sails lift, you are asked what migration strategy you want to use to keep the model in sync with the data store.  Being asked each time becomes annoying very quickly.  Lets go ahead and look at migration strategy options.</p>
<p>As you are developing your API and changing the models, you need to decide on the strategy to use for keeping your model in sync with your data store.  </p>
<h3 id="migration-options">Migration Options</h3>
<p>There are 3 options:</p>
<table>
<thead>
<tr>
<th>Migration Strategy</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>safe</td>
<td>never auto-migrate.  you will perform the migration by hand</td>
</tr>
<tr>
<td>alter</td>
<td>auto-migrate columns/fields but attempt to keep existing data</td>
</tr>
<tr>
<td>drop</td>
<td>wipe/drop ALL data and rebuild models every time you run sails lift</td>
</tr>
</tbody>
</table>
<h3 id="how-auto-migrations-work">How auto-migrations work</h3>
<p>When you lift your Sails app in a development environment, the configured auto-migration strategy will run. </p>
<ul>
<li><p>If you are using migrate: &#39;safe&#39;, then nothing extra will happen at all. </p>
</li>
<li><p>If you are using drop or alter, Sails will load every record in your development database into memory, then drop and recreate the physical layer representation of the data (i.e. tables/collections/sets/etc.) This allows any breaking changes you&#39;ve made in your model definitions, like removing a uniqueness constraint, to be automatically applied to your development database. </p>
</li>
<li><p>As well if you are using alter, Sails will then attempt to re-seed the freshly generated tables/collections/sets with the records it saved earlier.</p>
</li>
</ul>
<h3 id="can-i-use-auto-migrations-in-production-">Can I use auto-migrations in production?</h3>
<p>The drop and alter auto-migration strategies in Sails exist as a feature for your convenience during development, and when running automated tests. They are not designed to be used with data you care about. Please take care to never use drop or alter with a production dataset. </p>
<p>As a failsafe, any time you lift your app in a production environment, Sails always uses migrate: &#39;safe&#39;, no matter what you have configured.</p>
<p>In many cases, hosting providers automatically set the NODE_ENV environment variable to &quot;production&quot; when they detect a Node.js app. Even so, please don&#39;t rely only on that failsafe, and take the usual precautions to keep your users&#39; data safe. </p>
<h3 id="set-migrate-strategy">Set Migrate Strategy</h3>
<h4 class="exercise-start">
    <b>Exercise</b>: Set Migrate Strategy
</h4>

<p>Since we are in development, we are going to use the alter strategy to have Sails keep our model in sync with our data store.  </p>
<ol>
<li>Open the config\models.js file</li>
<li><p>At the bottom of the file uncomment the migrate line</p>
<pre><code class="lang-javascript"> migrate: &#39;alter&#39;
</code></pre>
</li>
</ol>
<div class="exercise-end"></div>

				</div>
				<hr>
				<div class="chapter">
					<h2 id="overriding-built-in-rest-verbs">Overriding Built-In REST Verbs</h2>
<p>Up to this point we have been using all of the built-in REST function.  However, we are going to want to create our own function with our own business logic.  </p>
<p>Here is a short list of some of the business logic we will be creating:</p>
<ul>
<li>Validate that the email address is an actual email address</li>
<li>Encrypted the password</li>
<li>Remove the encrypted password from the returned json</li>
<li>Only allow a user to get, update and delete data that they own</li>
<li>Allow a user to signup </li>
<li>Allow a user to login</li>
<li>Allow a user to sign out
Be able to query to the current logged in user</li>
<li>Associate a user to a todo item</li>
<li>Store the logged in user in session state</li>
</ul>
<h3 id="function-map">Function Map</h3>
<p>To override the built-in get, post, put, and delete, we will be creating methods in the controller.  Below is the mapping of REST verbs to function names.</p>
<table>
<thead>
<tr>
<th>VERB</th>
<th>Method Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>POST</td>
<td>create</td>
<td>Insert new record</td>
</tr>
<tr>
<td>GET</td>
<td>find</td>
<td>Get all records</td>
</tr>
<tr>
<td>GET/:id</td>
<td>findOne</td>
<td>Get record by ID</td>
</tr>
<tr>
<td>PUT</td>
<td>update</td>
<td>Update record</td>
</tr>
<tr>
<td>DELETE</td>
<td>destroy</td>
<td>Remove record</td>
</tr>
</tbody>
</table>
<h3 id="function-format">Function Format</h3>
<p>The standard format of the sails controller function looks like the following with replacing <em>METHOD_NAME</em> with the method name from above.   </p>
<h4 class="exercise-start">
Function Format Example
</h4>

<pre><code class="lang-javascript">METHOD_NAME: function METHOD_NAMEFn(req, res) {
     // get body of the request
     var body = req.body; 

     // get id from either querystring or body
     var id = req.params.id; 
}
</code></pre>
<p>This format for the function is the same for the custom functions that we will be creating for logging in and logging out. </p>
<div class="exercise-end"></div> 


				</div>
				<hr>
				<div class="chapter">
					<h2 id="user-api-logic">User API Logic</h2>
<p>In this chapter we are going to add logic to allow a user to login, signup, logout, perform CRUD (<strong>C</strong>reate, <strong>R</strong>ead, <strong>U</strong>pdate, <strong>D</strong>elete) operations on the data that they own.</p>
<h3 id="signup">Signup</h3>
<p>We are going to override the POST verb with our own create function that will validate that the email address is an actual email address, encrypt the password and create a user record in the data store.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Allow a User to Signup
</h4>

<p>The first thing we need to do is create our method stub.</p>
<ol>
<li><p>Open the api\controllers\UserController.js file</p>
<pre><code class="lang-bash"> usercontroller.js
</code></pre>
 <div class="alert alert-info" role="alert">In Visual Studio Code, use Ctrl+P to bring up the find file dialog, paste in the file name, and either click on the file or arrow down to it and press enter</div>
</li>
<li><p>Within the module.exports add the following function stub to override the POST verb</p>
<pre><code class="lang-javascript"> create: function createFn(req, res){

 }
</code></pre>
</li>
<li><p>By creating the above method, Sails will automatically use this method for the POST verb without us having to do any route configurations.</p>
</li>
</ol>
<div class="exercise-end"></div>


<h4 class="exercise-start">
    <b>Exercise</b>: Validate Email Address
</h4>

<p>The first thing we want to do when a user signs up is to validate that their email address is an actual email address.  To validate the email address, we are going to use Node Machine Packs.</p>
<p>Node Machine Packs are single purpose npm libraries.  For example the Email Address machine pack only has 1 function: validate instead of having a whole slew of helper function.  This makes the machine packs very lightweight.  </p>
<p>The only downside to using the machine packs is that you will have to use callbacks instead of promises within the Sails functions that we create that uses a machine pack.</p>
<p>Before we can use a Machine Pack we need to install the pack.  They are installed using NPM.  </p>
<ol>
<li>Open the Visual Studio Code Integrated Terminal</li>
<li><p>Run the following command to install the machinepack-emailaddresses that will be used to validate the email address</p>
<pre><code class="lang-bash"> npm install --save machinepack-emailaddresses
</code></pre>
</li>
<li><p>In the api\controllers\UserController.js file at the top outside of the module.exports, we need to import the machinepack-emailaddresses</p>
<pre><code class="lang-javascript"> var EmailAddresses = require(&#39;machinepack-emailaddresses&#39;);
</code></pre>
</li>
</ol>
<p>Within the create function we are ready to start adding in our logic.    </p>
<ol>
<li><p>Create a variable that gets the email address from the req parameters (body)</p>
<pre><code class="lang-javascript"> var email = req.param(&#39;email&#39;);
</code></pre>
</li>
<li><p>Call the EmailAddress.validate function to validate the email address and then check the results.  The Validate function has 3 possible returns:  error, invalid, and success. If there is an error we will return a server error (500 status code).  If the email is not valid then we will return a bad request (400 status code).  If the email is valid, then we will move on to encrypting the password. </p>
<pre><code class="lang-javascript">// validate the email address that is passed in
EmailAddresses.validate({
  string: email,
}).exec({
    // called if there is a general error
    error: function(err){
        return res.serverError(err);
    },

    // called if email is invalid
    invalid: function(){
        return res.badRequest(&#39;Does not look like an email address to me!&#39;);
    },

    // called if the email validation passed
    success: function(){
    }
});
</code></pre>
</li>
</ol>
<p>Within the success callback for the email validate we are ready to encrypt the password.  We will be using the machinepack-passwords to do the encryption and validating that the encrypted password and unencrypted passwords match.</p>
<ol>
<li>Open the Visual Studio Code Integrated Terminal</li>
<li><p>Install the machinepack-passwords</p>
<pre><code class="lang-bash"> npm install --save machinepack-passwords
</code></pre>
</li>
<li><p>At the top of the UserController, we need to add a require statement for the machinepack-passwords</p>
<pre><code class="lang-javascript"> var Passwords = require(&#39;machinepack-passwords&#39;);
</code></pre>
</li>
<li><p>Within the success callback for the email validate we need to call the Passwords.encryptPassword function and pass it the password from the request parameters (body).  The Passwords.encryptPassword function returns back 2 responses:  error or success.  If there is an error, we will return a server error (500 status code).  If it is successful, we will create the user in our data store.</p>
<pre><code class="lang-javascript"> // encrypt the password
 // get password from the body of the request with the req.param call
 Passwords.encryptPassword({
     password: req.param(&#39;password&#39;),
 }).exec({
     // if there is an error return a server error 500 status code
     error: function(err){
         return res.serverError(err);
     },

     // if success then move on to the next step
     success: function(result){
     }
 })
</code></pre>
</li>
</ol>
<p>Now we are ready to create our user in the data store and add the user to the request session.  Within the success callback add the following code to create a user with email and encryptedPassword fields.  We will get the email from the local variable that we created earlier and the encryptedPassword will come from the results of the Password.encryptPassword call.  To add the record to the data store, we are using the Waterline ORM and calling User.create.  Waterline allows us to write data store agnostic code.</p>
<ol>
<li><p>Within the success callback add the following code to create a local user variable</p>
<pre><code class="lang-javascript">// create user with email and encryptedPassword to add to the database
var user = {
    email: email,
    encryptedPassword: result
};
</code></pre>
</li>
<li><p>After the user variable declaration, call the Waterline ORM create function to create a new record based on the user variable that we created in the previous step </p>
<pre><code class="lang-javascript"> // User waterline to create a new user by calling .create and passing in the local user variable
 User.create(user, function (err, createdResult) {
     // check for errors
     if (err) res.serverError(err);

     // add user id to session state
     req.session.user = createdResult.id;

     // return back created user with a status code of 200
     // see api\responses\ok.js for what the ok response is actually doing
     return res.ok(createdResult);
 });
</code></pre>
</li>
<li><p>In order to test the create function, we have to restart the sails lift.  Stop sails lift using ctrl+c and run sails lift </p>
</li>
<li><p>Now if you run the POST call against the User API, you will see if returns back a user with an encryptedPassword (<em>step 8</em>)</p>
<p> <img src="images/postman-user-custom-create.png" alt="Postman user custom create"></p>
</li>
</ol>
<p>If you run into issues, here is the full code for the create function</p>
<pre><code class="lang-javascript">var EmailAddresses = require(&#39;machinepack-emailaddresses&#39;);
var Passwords = require(&#39;machinepack-passwords&#39;);

module.exports = {
create: function createFn(req, res) {
    var email = req.param(&#39;email&#39;);

    // validate the email address that is passed in
    EmailAddresses.validate({
        string: email,
    }).exec({
    // called if there is a general error
    error: function (err) {
        return res.serverError(err);
    },

    // called if email is invalid
    invalid: function () {
        return res.badRequest(&#39;Does not look like an email address to me!&#39;);
    },

    // called if the email validation passed
    success: function () {
        // encrypt the password
        // get password from the body of the request with the req.param call
        Passwords.encryptPassword({
            password: req.param(&#39;password&#39;),
        }).exec({
        // if there is an error return a server error 500 status code
        error: function (err) {
            return res.serverError(err);
        },

        // if success then move on to the next step
        success: function (result) {
            // create user with email and encryptedPassword to add to the database
            var user = {
                email: email,
                encryptedPassword: result
            };

            // User waterline to create a new user by calling .create and passing in the local user variable
            User.create(user, function (err, createdResult) {
                // check for errors
                if (err) res.serverError(err);

                // add user id to session state
                req.session.user = createdResult.id;

                // return back created user with a status code of 200
                // see api\responses\ok.js for what the ok response is actually doing
                return res.ok(createdResult);
            });
        }
        })
    }
    });
}
},
</code></pre>
<div class="exercise-end"></div>

<h3 id="remove-password-from-json">Remove Password from JSON</h3>
<p>It is an improvement that we are now encrypting the password but it is still passing the encrypted hash across the wire.  This is not a good security practice.  There is no reason to pass the encrypted password back from the API.  </p>
<h4 class="exercise-start">
    <b>Exercise</b>: Stripping the encryptedPassword from JSON
</h4>

<ol>
<li><p>Open the api\models\User.js</p>
<pre><code class="lang-bash"> user.js
</code></pre>
</li>
<li><p>Within the attributes we are going to create a function called toJSON</p>
<pre><code class="lang-javascript"> toJSON: function (){

 }
</code></pre>
</li>
<li><p>Within the toJSON function we need to get a reference to the current record by calling this.toObject() and setting the output a variable</p>
<pre><code class="lang-javascript"> var obj = this.toObject();
</code></pre>
</li>
<li><p>Now that we have a reference to the current record (object), we can call delete to remove the encryptedPassword field from the JSON results</p>
<pre><code class="lang-javascript"> delete obj.encryptedPassword;
</code></pre>
</li>
<li><p>The last thing left to do is return back the object</p>
<pre><code class="lang-javascript"> return obj;
</code></pre>
</li>
<li><p>Now if you run the GET call for the user, you will see that the encryptedPassword field is no longer returned back from the API</p>
<p> <img src="images/postman-user-without-encryptedPassword.png" alt="User Get without EncryptedPassword"></p>
</li>
</ol>
<div class="exercise-end"></div>

<h3 id="make-sure-email-is-unique">Make sure Email is unique</h3>
<h4 class="exercise-start">
    <b>Exercise</b>: Defining Fields
</h4>

<pre><code class="lang-javascript">email: {
    required: &#39;true&#39;,
    type: &#39;string&#39;,
    unique: true,
},
encryptedPassword: {
    required: &#39;true&#39;,
    type: &#39;string&#39;,
},
</code></pre>
<div class="exercise-end"></div>

<h3 id="login">Login</h3>
<h4 class="exercise-start">
    <b>Exercise</b>: 
</h4>

<pre><code class="lang-javascript"> login: function loginFn(req, res) {
    User.findOne(
        { email: req.param(&#39;email&#39;) }, 
        function (err, result) {
            if (err) return res.serverError(err);
            if (!result) return res.notFound();

            Passwords.checkPassword({
                passwordAttempt: req.param(&#39;password&#39;),
                encryptedPassword: result.encryptedPassword
            }).exec({
                error: function (err) {
                    return res.serverError(err);
                },

                incorrect: function () {
                    return res.forbidden(&#39;Invalid Login, Please Try Again!&#39;);
                },

                success: function () {
                    req.session.user = result.id;

                    return res.ok(result);
                }
            })
        }
    );
  },
</code></pre>
<div class="exercise-end"></div>

<h3 id="logout">Logout</h3>
<h4 class="exercise-start">
    <b>Exercise</b>: 
</h4>

<pre><code class="lang-javascript">logout: function logoutFn(req, res) {
    req.session.user = null;

    return res.ok();
},
</code></pre>
<div class="exercise-end"></div>

<h3 id="get-user-info">Get User Info</h3>
<h4 class="exercise-start">
    <b>Exercise</b>: 
</h4>

<pre><code class="lang-javascript">find: function findFn(req, res) {
    User.find(
        { id: req.session.user }, 
        function (err, results) {
            if (err) return res.serverError(err);
            if (results.length === 0) return res.notFound();

            return res.ok(results);
        }
    );
},
findOne: function findOneFn(req, res) {
    User.findOne(
        { id: req.session.user }, 
        function (err, result) {
            if (err) return res.serverError(err);
            if (!result) return res.notFound();

            return res.ok(result);
        }
    );
},
</code></pre>
<div class="exercise-end"></div>

<h3 id="delete-user">Delete User</h3>
<h4 class="exercise-start">
    <b>Exercise</b>: 
</h4>

<pre><code class="lang-javascript">
</code></pre>
<div class="exercise-end"></div>

<h3 id="update-user">Update User</h3>
<h4 class="exercise-start">
    <b>Exercise</b>: 
</h4>

<pre><code class="lang-javascript">
</code></pre>
<div class="exercise-end"></div>

<h3 id="who-is-logged-in-">Who is Logged In?</h3>
<h4 class="exercise-start">
    <b>Exercise</b>: 
</h4>

<pre><code class="lang-javascript">userIdentity: function (req, res) {
    User.findOne(
        { id: req.session.user }, 
        function (err, result) {
            if (err) return res.serverError(err);
            if (!result) return res.notFound();

            return res.ok(result);      
        }
    );
},
</code></pre>
<div class="exercise-end"></div>

				</div>
				<hr>
				<div class="chapter">
					<h2 id="todo-api-logic">Todo API Logic</h2>
<h3 id="create-todo">Create Todo</h3>
<h4 class="exercise-start">
    <b>Exercise</b>: Create Todo
</h4>


<pre><code class="lang-javascript">create: function createFn(req, res) {
    var todo = {
      item: req.param(&#39;item&#39;),
      completed: req.param(&#39;completed&#39;),
      user: req.session.user
    };

    Todo.create(todo, function (err, results) {
      if (err) res.serverError(err);
      return res.ok(results);
    });
},
</code></pre>
<ol>
<li>Todo.js</li>
</ol>
<pre><code class="lang-javascript">item: {
    required: &#39;true&#39;,
    type: &#39;string&#39;
},
completed: {
    required: &#39;true&#39;,
    type: &#39;boolean&#39;,
    defaultsTo: &#39;false&#39;
},
</code></pre>
<div class="exercise-end"></div>

<h3 id="get-todo-list">Get Todo List</h3>
<h4 class="exercise-start">
    <b>Exercise</b>: Get Todo List
</h4>

<pre><code class="lang-javascript">find: function findFn(req, res) {
    Todo.find(
        { 
            user: req.session.user 
        }
    )
    .populate(&#39;user&#39;)
    .exec(function (err, results) {
        if (err) return res.serverError(err);
        if (results.length === 0) return res.notFound();

        return res.ok(results);
    });
},
</code></pre>
<div class="exercise-end"></div>

<h3 id="get-single-todo">Get Single Todo</h3>
<h4 class="exercise-start">
    <b>Exercise</b>: Find Single Todo Item
</h4>

<pre><code class="lang-javascript">findOne: function findOneFn(req, res) {
    Todo.findOne(
        { 
            user: req.session.user 
        }
    )
    .populate(&#39;user&#39;)
    .exec(function (err, result) {
        if (err) return res.serverError(err);
        if (!result) return res.notFound();

        return res.ok(result);
    });
}
</code></pre>
<div class="exercise-end"></div>

<h3 id="update-todo">Update Todo</h3>
<h4 class="exercise-start">
    <b>Exercise</b>: Update Single Todo
</h4>

<pre><code class="lang-javascript">update: function (req, res) {
    Todo.findOne(
        { 
            user: req.session.user, 
            id: req.param(&#39;id&#39;) 
        }, 
        function (err, found) {
            found.item = req.param(&#39;item&#39;);
            found.completed = req.param(&#39;completed&#39;);

            Todo.update(
                {
                    user: req.session.user,
                    id: req.param(&#39;id&#39;)
                }, 
                found,
                function (err, results) {
                    if (err) res.serverError(err);
                    return res.ok(results);
                }
            );
        }
    );
},
</code></pre>
<div class="exercise-end"></div>

<h3 id="delete-todo">Delete Todo</h3>
<h4 class="exercise-start">
    <b>Exercise</b>: Delete Single Todo
</h4>

<pre><code class="lang-javascript">delete: function (req, res) {
    Todo.delete(
        { 
            user: req.session.user, 
            id: req.param(&#39;id&#39;),
        }, 
        function (err, results) {
            if (err) res.serverError(err);
            return res.ok(results);
        }
    );
},
</code></pre>
<div class="exercise-end"></div>

<h3 id="find-only-not-completed-todo">Find Only Not Completed Todo</h3>
<h4 class="exercise-start">
    <b>Exercise</b>: Create Method to Return Only Open
</h4>

<pre><code class="lang-javascript">findOnlyOpen: function findOnlyOpenFn(req, res) {
    Todo.find({
        user: req.session.user,
        completed: false,
    })
    .populate(&#39;user&#39;)
    .exec(function (err, results) {
        if (err) return res.serverError(err);
        if (results.length === 0) return res.notFound();

        return res.ok(results);
    });
},
</code></pre>
<div class="exercise-end"></div>

<h3 id="associating-user-to-todo-items">Associating User to Todo Items</h3>
<h4 class="exercise-start">
    <b>Exercise</b>: Associate Models
</h4>

<ol>
<li><p>Todo.js</p>
<pre><code class="lang-javascript"> user: {
   model: &#39;user&#39;
 }
</code></pre>
</li>
<li><p>User.js</p>
<pre><code class="lang-javascript"> todoItems: {
   collection: &#39;todo&#39;,
   via: &#39;user&#39;
 },
</code></pre>
</li>
</ol>
<div class="exercise-end"></div>

				</div>
				<hr>
				<div class="chapter">
					<h2 id="locking-down-the-api">Locking Down the Api</h2>
<p>Update to this point you have had to remember to call the Login or Signup routes before you can see or update Todo items.  It would be much better if we directed users with errors messages that tell them that they need to perform an authentication call before trying to make a call.  </p>
<p>In order to do the authentication checks, Sails uses policies to lock down routes.  A policy is essential a function that returns a true/false value for whatever check you need to do.  </p>
<p>Policies are stored in the api\policies directory.  By creating a file in  the policies directory, they are automatically ready to be used to lock down a route.  </p>
<p>We will be creating 2 policies:  </p>
<ol>
<li>Check if you are logged in  </li>
<li>Check if you are logged out</li>
</ol>
<h3 id="policy-to-check-if-logged-in">Policy to Check if Logged In</h3>
<h4 class="exercise-start">
    <b>Exercise</b>: Create Is Logged In Policy
</h4>

<ol>
<li><p>In the api\policies folder, create a new JavaScript file called isLoggedIn.js</p>
<pre><code class="lang-bash"> isLoggedIn.js
</code></pre>
</li>
<li><p>The function format for Sails policies as follows.  It takes in a request, response, and next option.  </p>
<pre><code class="lang-javascript"> module.exports = function(req, res, next) {

 }
</code></pre>
</li>
<li><p>Within the policy function, we will use the req.session.user to determine if the user has logged in yet or not.  If the user has logged in, we need call next to go to the next policy in the chain.  If the user has not logged in, we will return the forbidden response.</p>
<pre><code class="lang-javascript"> module.exports = function(req, res, next) {
     if (req.session.user) {
         return next();
     }

     return res.forbidden(&#39;Please Login First.&#39;);
 }
</code></pre>
</li>
</ol>
<div class="exercise-end"></div>

<h3 id="policy-to-check-if-logged-out">Policy to Check if Logged Out</h3>
<h4 class="exercise-start">
    <b>Exercise</b>: Create Is Logged Out Policy
</h4>

<ol>
<li><p>In the api\policies folder, create a new JavaScript file called isLoggedOut.js</p>
<pre><code class="lang-bash"> isLoggedOut.js
</code></pre>
</li>
<li><p>Remember that the function format for Sails policies as follows.  It takes in a request, response, and next option.  </p>
<pre><code class="lang-javascript"> module.exports = function(req, res, next) {

 }
</code></pre>
</li>
<li><p>Within the policy function, we will use the req.session.user to determine if the user has logged in yet or not.  If the user has not logged in, we will call to go to the next policy in the chain. If the user has logged in, we will return the forbidden response.  </p>
<pre><code class="lang-javascript"> module.exports = function(req, res, next) {
     if (!req.session.user) {
         return next();
     }

     return res.forbidden(&#39;Please Logout First&#39;);
 }
</code></pre>
</li>
</ol>
<div class="exercise-end"></div>

<h3 id="locking-down-routes">Locking Down Routes</h3>
<p>Now that we have both of our policies created, we need to configure which routes will use which policy.  </p>
<table>
<thead>
<tr>
<th>Controller</th>
<th>Function</th>
<th>Policy</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>UserController</td>
<td>login</td>
<td>true</td>
<td>Let everyone make a call to login</td>
</tr>
<tr>
<td>UserController</td>
<td>create</td>
<td>[&#39;isLoggedOut&#39;]</td>
<td>Make sure that you are logged out before trying to login again</td>
</tr>
<tr>
<td>UserController</td>
<td>*</td>
<td>[&#39;isLoggedIn&#39;]</td>
<td>All routes that aren&#39;t already configured will use this policy chain</td>
</tr>
<tr>
<td>TodoController</td>
<td>*</td>
<td>[&#39;isLoggedIn&#39;]</td>
<td>All routes in Todo controller will use this policy</td>
</tr>
</tbody>
</table>
<h4 class="exercise-start">
    <b>Exercise</b>: Locking Down Routes
</h4>

<ol>
<li><p>Open config\policies.js</p>
<pre><code class="lang-bash"> policies.js
</code></pre>
</li>
<li><p>Add the following to the list of models that are locked down</p>
<pre><code class="lang-JavaScript"> UserController: {
     &#39;login&#39;: true,
     &#39;create&#39;: [&#39;isLoggedOut&#39;],
     &#39;*&#39;: [&#39;isLoggedIn&#39;]
 },
 TodoController: {
     &#39;*&#39;: [&#39;isLoggedIn&#39;]
 }
</code></pre>
</li>
</ol>
<div class="exercise-end"></div>

<h3 id="testing-out-policy">Testing out policy</h3>
<p>We are now ready to test that our security is working.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Testing policy
</h4>

<ol>
<li><p>Restart sails lift.  If you already have sails lift running, you need to ctrl+c to stop running it and restart it.  Policies do not automatically up themselves as you change the code until sails lift is restarted.</p>
</li>
<li><p>For the User routes, if you try to do any call besides a POST, you will get a message that you need to login first</p>
</li>
<li>For the Todo routes, if you try to do any call you will get a message that you need to login first</li>
<li><p>Once you call the login route you will be able to do the following:</p>
<ul>
<li>For User routes, you will be able to do a GET, PUT, and DELETE call.  </li>
<li>For Todo routes, you will be able to call all routes</li>
<li>If you call the login route again, you will get a message that you need to logout first.</li>
</ul>
</li>
</ol>
<div class="exercise-end"></div>

				</div>
				<hr>
				<div class="chapter">
					<h2 id="routing">Routing</h2>
<h3 id="controlling-the-api-route-url">Controlling the Api Route Url</h3>
<p>In the Api project, you can also change how to route to the custom method by setting your own route in the config\routes.js file.  </p>
<h4 class="exercise-start">
    <b>Exercise</b>: Create Todo
</h4>

<ol>
<li><p>Open the config/routes.js</p>
<pre><code class="lang-javascript"> &#39;GET /user/identity&#39;: &#39;UserController.userIdentity&#39;
</code></pre>
</li>
<li><p>For the route to take effect you will need to stop the <code>sails lift</code> with a ctrl+c and then re-run the <code>sails lift</code></p>
</li>
</ol>
<div class="exercise-end"></div>

				</div>
				<hr>
				<div class="chapter">
					<h2 id="connecting-to-mongodb">Connecting to MongoDB</h2>
<p>Coming soon...</p>

				</div>
				<hr>
				<div class="chapter">
					<h2 id="cors-configuration">CORS Configuration</h2>
<h4 class="exercise-start">
    <b>Exercise</b>: CORS Config
</h4>

<pre><code class="lang-javascript">
</code></pre>
<div class="exercise-end"></div>

				</div>
				<hr>
				<div class="chapter">
					<h2 id="deploying">Deploying</h2>
<h3 id="deploy-to-heroku">Deploy to Heroku</h3>
<p>Coming soon...</p>
<h3 id="deploy-to-azure">Deploy to Azure</h3>
<p>Coming soon...</p>

				</div>
				<hr>
				<div class="chapter">
					<h2 id="unit-testing">Unit Testing</h2>
<p>Coming soon.....</p>

				</div>
				<hr>
				<div class="chapter">
					<h2 id="linting">Linting</h2>
<p>Coming soon...</p>

				</div>
				<hr>
				<div class="chapter">
					<h2 id="thank-you">Thank you</h2>
<p>I hope that you enjoyed going through this tutorial.    You now have everything that you need to start developing your own Sails based API.  </p>

				</div>
			</div>
		</div>
	</div>

	<script src="scripts/built.js"></script>

</body>

</html>
