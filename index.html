<!DOCTYPE html>
<html lang="en">

<head>
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Sails Tutorial</title>


	<meta charset="utf-8">
	<meta name="description" content="Sails Workshop">
	<meta name="author" content="Justin James">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="css/style.css" rel="stylesheet">
</head>

<body>

	<div id="tutorial-container">
		<div id="header">
			<a href="#" class="menu header-btn" id="toggle-toc"></a>
			<h1>Sails Tutorial</h1>
			<a href="https://github.com/digitaldrummerj/sails-tutorial" class="github header-btn"></a>
		</div>
		<div id="tutorial-content-container">

			<div id="toc">
				<div class="toc-heading">Table of Contents</div>
				<div id="toc-padding"></div>
			</div>
			<div id="book">
				<div class="chapter">
					<h2 id="introduction">Introduction</h2>
<p>Welcome to the Sails Tutorial.  </p>
<p>In this tutorial, you&#39;ll learn how to build a Sails Api. Throughout the tutorial, you will be building a todo api.  </p>
<h3 id="materials">Materials</h3>
<ul>
<li><a href="https://www.slideshare.net/digitaldrummerj/rapid-api-development-with-node-and-sails">Presentation</a></li>
</ul>

				</div>
				<hr>
				<div class="chapter">
					<h2 id="getting-up-and-running">Getting up and running</h2>
<p>We will utilize a number of tools in our Sails development to allow us to create, debug, and deploy our application.  We will be utilizing the following tools:</p>
<ul>
<li>Platforms: Windows, Mac, or Linux computer</li>
<li>Software:<ul>
<li>git command line</li>
<li>Node 6.x</li>
<li>sails</li>
<li>Postman    </li>
<li>Visual Studio Code</li>
</ul>
</li>
</ul>
<p>Below are all of the steps required to install and configure the tools.  </p>
<h3 id="windows-showing-file-extensions">Windows Showing File Extensions</h3>
<div class="alert alert-danger" role="alert">
<strong>Windows Only</strong>
</div>

<p><strong>Non-Windows users can <a href="#chapter2.4">skip to next section</a></strong></p>
<p>By default Windows is set to not show file extensions for known files which causes files such as .gitconfig and .npmrc to show up as just a period with no file extensions.  To fix this we need to set Windows Explorer to show file extensions.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Turn On Windows Showing File Extensions
</h4>

<ol>
<li>Open Windows Explorer</li>
<li><p>Click on the View Tab and select Options</p>
<p> <img src="images/chapter1/windows-explorer-ribbon.png"></p>
</li>
<li><p>Click on the View Tab</p>
</li>
<li>Uncheck the &quot;Hide extensions for known file types&quot;</li>
<li><p>Click Ok</p>
<p> <img src="images/chapter1/windows-explorer-view-options.png"></p>
</li>
</ol>
<div class="exercise-end"></div>

<h3 id="node-js">Node.js</h3>
<p>NodeJS is used to power the Sails CLI as well as install all of our dependencies.  The Sails CLI will work with Node 4.x+.  Since I am using Angular for my UI which requires Node version 6.9+, we are going to install the latest LTS version of Node which as of this writing is 6.11.0..</p>
<h4 class="exercise-start">
<b>Exervise</b>: Install Node
</h4>

<ol>
<li>Download the latest stable version (LTS) of <a href="http://nodejs.org">NodeJS</a>.  </li>
<li>Run the installer and accept all defaults.</li>
<li><p>To validate that Node installed successfully, open a new command prompt and run the following command:</p>
<pre><code class="lang-bash">node -v
</code></pre>
</li>
</ol>
<div class="exercise-end"></div>

<h3 id="sails-js">Sails.js</h3>
<h4 class="exercise-start">
    <b>Exercise:</b>: Install Sails Globally
</h4>

<ol>
<li>Open a terminal window if it&#39;s not already open</li>
<li><p>Execute the following command to install Sails:</p>
<pre><code class="lang-bash"> npm install -g sails
</code></pre>
</li>
<li><p>Validate that Sails installed successfully by running the following command:</p>
<pre><code class="lang-bash"> sails -v
</code></pre>
<blockquote>
<p>0.12.13 as of this writing</p>
</blockquote>
</li>
</ol>
<div class="exercise-end"></div>

<h3 id="postman">Postman</h3>
<p>Postman is a useful utility for testing REST apis without having to create a UI.</p>
<ol>
<li>You can download it from <a href="https://www.getpostman.com/apps">https://www.getpostman.com/apps</a></li>
<li>Once the download finishes, launch the installer and accept all of the defaults</li>
</ol>
<h3 id="visual-studio-code">Visual Studio Code</h3>
<p>Visual Studio Code is Microsoft lightweight cross platform IDE.  You could use any editor that you would like to developer our  Sails but only Visual Studio Code has been tested against</p>
<ol>
<li>Download Visual Studio Code at <a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a></li>
<li>Once the download finishes, launch the installer except all of the defaults</li>
</ol>

				</div>
				<hr>
				<div class="chapter">
					<h2 id="creating-sails-api">Creating Sails Api</h2>
<p>We will utilize the Sails CLI to generate a project for us to developer our API with.  By default Sails comes with a view engine unless you tell it otherwise.  When we create our project we will only  be creating an API project and will not include the view engine as part of the project. </p>
<h3 id="create-project">Create Project</h3>
<h4 class="exercise-start">
    <b>Exercise</b>: Create Sails Project
</h4>

<p>To generate the project we need to run the intc gen-ui command.</p>
<ol>
<li>Open a command prompt or terminal</li>
<li>Navigate to where you store your project code (I store mine at c:\projects)</li>
<li><p>Run the following command to generate the project.  </p>
<pre><code> sails new sails-tutorial --no-linker --no-frontend
</code></pre> <div class="alert alert-info" role="alert">This will create a new Sails project called sails-tutorial and install the npm dependencies</div>

</li>
</ol>
<div class="exercise-end"></div>

<h3 id="opening-project-in-visual-studio-code">Opening Project in Visual Studio Code</h3>
<h4 class="exercise-start">
  <b>Exercise</b>: Open Project
</h4>

<ol>
<li>Open Visual Studio Code</li>
<li>Click File -&gt; Open Folder...</li>
<li>Navigate to where you created the sails-tutorial folder and click Select Folder </li>
<li>Your project should now be opened in Visual Studio Code</li>
</ol>
<div class="exercise-end"></div>

<h3 id="navigating-around-visual-studio-code">Navigating around Visual Studio Code</h3>
<p>Being able to effectively use your editor is key to being a super productive developer.  With Visual Studio Code, there are several shortcut keys that will help you out.</p>
<table>
<thead>
<tr>
<th>Purpose</th>
<th>Key</th>
</tr>
</thead>
<tbody>
<tr>
<td>Integrated Terminal</td>
<td>ctrl+`</td>
</tr>
<tr>
<td>Open File</td>
<td>ctrl+p</td>
</tr>
<tr>
<td>Switch Between Files</td>
<td>ctrl+tab</td>
</tr>
<tr>
<td>Switch Between Files Reverse</td>
<td>ctrl+shift+tab</td>
</tr>
<tr>
<td>Hide Side Menu</td>
<td>ctrl+b</td>
</tr>
<tr>
<td>Toggle Word Wrap for File</td>
<td>alt+z</td>
</tr>
<tr>
<td>Format Document</td>
<td>ctrl+alt+f</td>
</tr>
</tbody>
</table>
<div class="alert alert-info" role="alert"> I also split my screen in half with the tutorial on one side and the editor on the other side.  On Windows you can do this by using the win key + left arrow for the one you want on the left and then select the other for the right when windows prompts you.  You can also use win key + right arrow to make a Windows use half the screen on the right.</div>

<h3 id="visual-studio-settings">Visual Studio Settings</h3>
<p>There are 2 types of Settings in Visual Studio Code:  User and Workspace.  User settings apply to all instances of Visual Studio Code.  Workspace settings apply to the currently folder that you have open and are stored in a .vscode directory within the folder.</p>
<p>There are a few settings that I like to change within Visual Studio Code.  </p>
<ol>
<li>Turn off the mini map in the upper right corder that I find distracting</li>
<li>Turn off telemetry and crash reporter</li>
<li>Turn on word wrap</li>
<li>Turn on indent guides</li>
</ol>
<h4 class="exercise-start">
  <b>Exercise</b>: Updating Settings
</h4>

<ol>
<li>Go under the Preferences -&gt; Settings (File -&gt; Preferences -&gt; Settings on Windows) and add the following setting to the &quot;User Settings&quot; tab</li>
</ol>
<pre><code class="lang-bash">{
    &quot;telemetry.enableTelemetry&quot;: false,
    &quot;telemetry.enableCrashReporter&quot;: false,
    &quot;editor.minimap.enabled&quot;: false,
    &quot;editor.wordWrap&quot;: &quot;on&quot;,
    &quot;editor.wrappingIndent&quot;: &quot;same&quot;,
    &quot;editor.renderIndentGuides&quot;: true,
}
</code></pre>
<div class="exercise-end"></div>



				</div>
				<hr>
				<div class="chapter">
					<h2 id="sails-project-layout">Sails Project Layout</h2>
<h3 id="api-controllers">API Controllers</h3>
<blockquote>
<p>api/controllers</p>
</blockquote>
<p>Controllers are defined in the api/controllers/ folder. You can put any files you like in that folder, but in order for them to be loaded by Sails as controllers, a file must end in Controller.js. </p>
<p>Controllers (the C in MVC) are the principal objects in your Sails application that are responsible for responding to requests from a web browser, mobile application or any other system capable of communicating with a server. For many applications, the controllers will contain the bulk of your projectâ€™s business logic.</p>
<p>Controllers are comprised of a set of methods called actions. Actions are bound to routes, so that when a client requests the route, the action is executed to perform some business logic and send a response. </p>
<p>Using the command line you can generate a controller and model by using the sails generate command api</p>
<pre><code class="lang-bash">sails generate api &lt;API Name&gt;
</code></pre>
<p>Get more details on Controllers at <a href="http://sailsjs.org/documentation/concepts/controllers">http://sailsjs.org/documentation/concepts/controllers</a></p>
<h3 id="api-models">API Models</h3>
<blockquote>
<p>directory: api/models</p>
</blockquote>
<p>Models are defined in the api/models/ folder.</p>
<p>A model represents a collection of structured data, usually corresponding to a single table or collection in a database. </p>
<p> There are many built-in methods available on models, the most important of which are the query methods: <a href="http://sailsjs.org/documentation/reference/waterline/models/find.html">find</a>, <a href="http://sailsjs.org/documentation/reference/waterline/models/create.html">create</a>, <a href="http://sailsjs.org/documentation/reference/waterline/models/update.html">update</a>, and <a href="http://sailsjs.org/documentation/reference/waterline/models/destroy.html">destroy</a>. These methods are asynchronous - under the covers, Waterline has to send a query to the database and wait for a response.</p>
<p>Get more details on Models at <a href="http://sailsjs.org/documentation/concepts/models-and-orm/models">http://sailsjs.org/documentation/concepts/models-and-orm/models</a></p>
<h3 id="api-policies">API Policies</h3>
<blockquote>
<p>directory: api/policies</p>
</blockquote>
<p>Policies in Sails are used for authorization and access control.  Basically they let you allow or deny access to your controllers down to a fine level of granularity. </p>
<p>Policies can be used for anything: HTTP BasicAuth, 3rd party single-sign-on, OAuth 2.0, or your own custom authorization/authentication scheme.</p>
<p>Policies are files defined in the api/policies folder in your Sails app. Each policy file should contain a single function and ideally should just check one thing.</p>
<p>Policies are really just Connect/Express middleware functions which run before your controllers. They are designed to be chained together.  </p>
<p>See <a href="http://sailsjs.com/documentation/concepts/policies">Policies Docs</a></p>
<h3 id="api-responses">API Responses</h3>
<blockquote>
<p>directory: api/responses</p>
</blockquote>
<p>Sails allows for customizable server responses. Sails comes with a handful of the most common response types by default that are found in the /api/responses directory of our project. To customize these, simply edit the appropriate .js file.</p>
<p>Any .js script saved in the /api/responses folder will be executed by calling res.[responseName] in your controller. For example, /api/responses/serverError.js can be executed with a call to res.serverError(errors). The request and response objects are available inside the response script as this.req and this.res; this allows the actual response function to take arbitrary parameters (like serverError&#39;s errors parameter).</p>
<p>See <a href="http://sailsjs.com/documentation/concepts/custom-responses">Response Docs</a></p>
<h3 id="api-services">API Services</h3>
<blockquote>
<p>directory: api/services</p>
</blockquote>
<p>Services are defined in the api\services folder.</p>
<p>Services are stateless libraries of functions (called helpers) that you can use from anywhere in your Sails app.  They are globalized and you don&#39;t have to use require() to access them.  </p>
<p>See <a href="http://sailsjs.org/documentation/concepts/services">Services Docs</a></p>
<h3 id="configuration-overview">Configuration Overview</h3>
<p>Configuration files are defined in the config folder.</p>
<p>While Sails dutifully adheres to the philosophy of convention-over-configuration, it is important to understand how to customize those handy defaults from time to time. For almost every convention in Sails, there is an accompanying set of configuration options that allow you to adjust or override things to fit your needs.</p>
<p>Sails apps can be configured programmatically, by specifying environment variables or command-line arguments, by changing the local or global .sailsrc files, or (most commonly) using the boilerplate configuration files conventionally located in the config/ folder of new projects. The authoritative, merged-together configuration used in your app is available at runtime on the sails global as sails.config.</p>
<p>Get more details on Configuration at <a href="http://sailsjs.org/documentation/concepts/configuration">http://sailsjs.org/documentation/concepts/configuration</a></p>
<h3 id="configurations-environment">Configurations Environment</h3>
<blockquote>
<p>file: config/env/development.js and config/env/production.js</p>
</blockquote>
<h3 id="configurations-connections">Configurations Connections</h3>
<blockquote>
<p>file: config/connections.js</p>
</blockquote>
<p>Storage connections are configured in the connections.js file. You can also specify connections in your config/local.js or environment-specific config files and reference them in the connections.js file.</p>
<p>See <a href="http://sailsjs.com/documentation/reference/configuration/sails-config-connections">Docs</a></p>
<h3 id="configurations-cors">Configurations CORS</h3>
<blockquote>
<p>file: config/cors.js</p>
</blockquote>
<p>CORS specifies how HTTP requests to your app originating from foreign domains should be treated. It is primarily used to allow third-party sites to make AJAX requests to your app, which are normally blocked by browsers following the same-origin policy.</p>
<p>See <a href="http://sailsjs.com/documentation/reference/configuration/sails-config-cors">Docs</a></p>
<h3 id="configurations-locals">Configurations Locals</h3>
<blockquote>
<p>file: config/local.js</p>
</blockquote>
<p>The config/local.js file is used to configure a Sails app for your local environment. The settings in this file take precedence over all other config files except .sailsrc. Since they&#39;re intended only for local use, <strong>they should not be put under version control</strong> . Use local.js to store local database settings, change the port used when lifting an app on your computer, etc.</p>
<h3 id="configurations-models">Configurations Models</h3>
<blockquote>
<p>file: config/models.js</p>
</blockquote>
<p>Your default project-wide model settings. We will be using it to store your migrate strategy and the default connection to use for your models.  </p>
<p>You can also override the settings on a per-model basis.</p>
<p>See <a href="http://sailsjs.com/documentation/reference/configuration/sails-config-models">Docs</a></p>
<h3 id="configurations-policies">Configurations Policies</h3>
<blockquote>
<p>file: config/policies.js</p>
</blockquote>
<p>Your applications ACL (access control list) to apply to each controller and route.  Policies can be chained together using the array syntax.</p>
<p>See <a href="http://sailsjs.com/documentation/reference/configuration/sails-config-policies">Docs</a></p>
<h3 id="configurations-routes">Configurations Routes</h3>
<blockquote>
<p>file: config/routes.js</p>
</blockquote>
<p>Configuration for your routes.  For a given route you will configure: REST verb, url, controller and function that a route maps to.</p>
<p>See <a href="http://sailsjs.com/documentation/reference/configuration/sails-config-routes">Docs</a></p>
<h3 id="configurations-session">Configurations Session</h3>
<blockquote>
<p>file: config/session.js</p>
</blockquote>
<p>Configuration for Sails built-in session store.  You can add/get information from session by using req.session.  </p>
<p>See <a href="http://sailsjs.com/documentation/reference/configuration/sails-config-session">Docs</a></p>

				</div>
				<hr>
				<div class="chapter">
					<h2 id="generating-api">Generating Api</h2>
<p>Now that we have generated our project, before we can use it, we need to generate an Api.  Our Todo API will have two APIs:  User and Todo.  We will use the Sails CLI to generate the APIs.  </p>
<p>When you generate a new api it will create a model and controller for the API.  A model describes the data store fields with attributes such as type, required, unique, and defaultsTo.  The controller will contain our functions that are related to the model.  </p>
<p>Out of the box, Sails wires up all of the REST verbs (GET, POST, PUT, DELETE) for us and saves the data to a schema-less JSON file as the data store.  This means that immediately after running the generate command we can use the API without having to write any code. </p>
<h3 id="generating-user-api">Generating User API</h3>
<h4 class="exercise-start">
  <b>Exercise</b>: Generating User API
</h4>

<ol>
<li>Visual Studio Code has a built-in terminal that we can use to run our commands.  Open up the integrated terminal in Visual Studio Code  by using ctrl+` or view menu -&gt; Integrated Terminal</li>
<li><p>Run the following command to create the user API</p>
<pre><code class="lang-bash"> sails generate api user
</code></pre>
</li>
<li><p>This will create 2 files for us:</p>
<ul>
<li>api\controllers\UserController.js</li>
<li>api\models\User.js</li>
</ul>
</li>
</ol>
<div class="exercise-end"></div>

<h3 id="generating-todo-api">Generating Todo Api</h3>
<h4 class="exercise-start">
  <b>Exercise</b>: Generating Todo API
</h4>

<ol>
<li><p>In the Visual Studio Code integrated terminal (ctrl+` or view menu -&gt; Integrated Terminal), run the  following command to create the user API</p>
<pre><code class="lang-bash"> sails generate api todo
</code></pre>
</li>
<li><p>This will create 2 files for us:</p>
<ul>
<li>api\controllers\TodoController.js</li>
<li>api\models\Todo.js</li>
</ul>
</li>
</ol>
<div class="exercise-end"></div>

<h3 id="running-api">Running Api</h3>
<h4 class="exercise-start">
    <b>Exercise</b>: Turning Off Views
</h4>

<p>Even though we generated our project without any views, you will see an error when you run the project for the first time related to the views.  To fix this error, we need to set the views to false in the .sailsrc file.</p>
<ol>
<li>Open .sailsrc</li>
<li><p>To the hooks section, add the following name/value pair.  Make sure to add a comma after the <code>&quot;grunt&quot;: false</code></p>
<pre><code class="lang-javascript"> &quot;views&quot;: false
</code></pre>
</li>
<li><p>Save the file</p>
</li>
</ol>
<div class="exercise-end"></div>

<h4 class="exercise-start">
    <b>Exercise</b>: Starting Api
</h4>


<ol>
<li><p>In the Visual Studio Code integrated  terminal run the following command to start our API</p>
<pre><code class="lang-bash"> sails lift
</code></pre>
<p> <img src="images/db-migrate-question.png" alt="sails lift output"></p>
 <div class="alert alert-danger" role="alert">You will notice that you are prompted with a big long question about database migration strategy to use.  Sails does not make any assumptions on how we want it to deal with database migrations as the models are updated.  Out of the box Sails uses a schema-less JSON file as the data store.  This is what allows us to immediately started working with our API.  Until we set the database migration strategy to use, we will be prompted to select one when we run sails lift.</div>
</li>
<li><p>When prompted for the migration strategy, type 2 and press enter</p>
<p> <img src="images/db-migrate-answer.png" alt="sails lift started">    </p>
 <div class="alert alert-info" role="alert">You will see that a message shows up that says &quot;Temporarily using sails.config.models.migrate=&quot;alert&quot;...&quot;</div>
</li>
<li><p>The API is now started up and we are ready to do some testing with Postman</p>
</li>
</ol>
<div class="exercise-end"></div>

<h3 id="get-data">Get Data</h3>
<h4 class="exercise-start">
    <b>Exercise</b>: Get Data
</h4>


<ol>
<li>Open up Postman</li>
<li>Set the VERB to GET (<em>step 1</em>)</li>
<li><p>Set the url to <a href="http://localhost:1337/user">http://localhost:1337/user</a> (<em>step 2</em>)</p>
<pre><code class="lang-bash"> http://localhost:1337/user
</code></pre>
</li>
<li><p>Click the Send button (<em>step 3</em>)</p>
</li>
<li>Right now you should have gotten an empty array as we have not added any data yet (<em>step 4</em>)</li>
<li>You should have also gotten a status code of 200 (<em>step 5</em>)</li>
</ol>
<p><img src="images/postman-user-get-blank.png" alt="Postman get"></p>
<div class="exercise-end"></div>

<h3 id="insert-data">Insert Data</h3>
<h4 class="exercise-start">
    <b>Exercise</b>: Insert Data
</h4>

<p>We can insert data using the REST verb POST.</p>
<ol>
<li>In Postman, change the VERB to POST (<em>step 1</em>)</li>
<li><p>Leave the url set to <a href="http://localhost:1337/user">http://localhost:1337/user</a> (<em>step 2</em>)</p>
<pre><code class="lang-bash"> http://localhost:1337/user
</code></pre>
</li>
<li><p>Click on the Body tab (<em>step 3</em>)</p>
</li>
<li>Click raw radio button (<em>step 4</em>)</li>
<li>Change the type dropdown from &quot;Text&quot; to &quot;application/json&quot; (<em>step 5</em>)</li>
<li><p>Set the request body to the following JSON (<em>step 6</em>)</p>
<pre><code class="lang-json"> {
     &quot;email&quot;: &quot;foo@foo.com&quot;,
     &quot;password&quot;: &quot;123456&quot;
 }
</code></pre>
</li>
<li><p>Click the Send button (<em>step 7</em>)</p>
</li>
<li><p>You will get an output similar to the following. (<em>step 8 </em>)</p>
<pre><code class="lang-json"> {
     &quot;email&quot;: &quot;foo@foo.com&quot;,
     &quot;password&quot;: &quot;123456&quot;,
     &quot;createdAt&quot;: &quot;2017-07-23T22:09:29.601Z&quot;,
     &quot;updatedAt&quot;: &quot;2017-07-23T22:09:29.601Z&quot;,
     &quot;id&quot;: 1
 }
</code></pre>
</li>
<li><p>You should also have a status code of 201 (<em>step 9</em>)</p>
</li>
</ol>
<p><img src="images/postman-user-post.png" alt="Postman POST"></p>
<div class="exercise-end"></div>

<h3 id="update-data">Update Data</h3>
<h4 class="exercise-start">
    <b>Exercise</b>: Update Data
</h4>

<p>We can update data using the REST verb PUT.</p>
<ol>
<li>In Postman VERB to PUT (<em>step 1</em>)</li>
<li>Change the url to <a href="http://localhost:1337/user/1">http://localhost:1337/user/1</a> (<em>step 2</em>)</li>
<li>Click on the Body tab (<em>step 3</em>)</li>
<li>Click raw radio button (<em>step 4</em>)</li>
<li>Change the type dropdown from &quot;Text&quot; to &quot;application/json&quot; (<em>step 5</em>)</li>
<li><p>Set the request body to the following JSON (<em>step 6</em>)</p>
<pre><code class="lang-json"> {
     &quot;email&quot;: &quot;foo1@foo.com&quot;,
     &quot;password&quot;: &quot;1234567&quot;
 }
</code></pre>
</li>
<li><p>Click the Send button (<em>step 7</em>)</p>
</li>
<li><p>You will get an output similar to the following. (<em>step 8</em>)</p>
<pre><code class="lang-json"> {
     &quot;email&quot;: &quot;foo1@foo.com&quot;,
     &quot;password&quot;: &quot;1234567&quot;,
     &quot;createdAt&quot;: &quot;2017-07-23T22:09:29.601Z&quot;,
     &quot;updatedAt&quot;: &quot;2017-07-23T22:09:29.601Z&quot;,
     &quot;id&quot;: 1
 }
</code></pre>
</li>
<li><p>You should also have a status code of 201 (<em>step 9</em>)</p>
</li>
</ol>
<p><img src="images/postman-user-put.png" alt="Postman PUT"></p>
<div class="alert alert-info" role="alert">Right now update returns the record that we just deleted.  In the next Sails release it will not return any data.</div>

<div class="exercise-end"></div>

<h3 id="delete-data">Delete Data</h3>
<h4 class="exercise-start">
    <b>Exercise</b>: Delete Data
</h4>

<p>We can update data using the REST verb DELETE.</p>
<ol>
<li>In Postman VERB to DELETE (<em>step 1</em>)</li>
<li>Change the url to <a href="http://localhost:1337/user/1">http://localhost:1337/user/1</a> (<em>step 2</em>)</li>
<li>Click the Send button (<em>step 3</em>)</li>
<li><p>You will get an output similar to the following.  (<em>step 4</em>)</p>
<pre><code class="lang-json"> {
     &quot;email&quot;: &quot;foo1@foo.com&quot;,
     &quot;password&quot;: &quot;1234567&quot;,
     &quot;createdAt&quot;: &quot;2017-07-23T22:09:29.601Z&quot;,
     &quot;updatedAt&quot;: &quot;2017-07-23T22:09:29.601Z&quot;,
     &quot;id&quot;: 1
 }
</code></pre>
</li>
<li><p>You should also have a status code of 200 (<em>step 5</em>)</p>
</li>
</ol>
<p><img src="images/postman-user-delete.png" alt="Postman PUT"></p>
<div class="alert alert-info" role="alert">Right now delete returns the record that we just deleted.  In the next Sails release it will not return any data.</div>

<div class="exercise-end"></div>


				</div>
				<hr>
				<div class="chapter">
					<h2 id="model-migration-strategy">Model Migration Strategy</h2>
<p>Right now everytime you start sails lift, you are asked what migration strategy you want to use to keep the model in sync with the data store.  Being asked each time becomes annoying very quickly.  Lets go ahead and look at migration strategy options.</p>
<p>As you are developing your API and changing the models, you need to decide on the strategy to use for keeping your model in sync with your data store.  </p>
<h3 id="migration-options">Migration Options</h3>
<p>There are 3 options:</p>
<table>
<thead>
<tr>
<th>Migration Strategy</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>safe</td>
<td>never auto-migrate.  you will perform the migration by hand</td>
</tr>
<tr>
<td>alter</td>
<td>auto-migrate columns/fields but attempt to keep existing data</td>
</tr>
<tr>
<td>drop</td>
<td>wipe/drop ALL data and rebuild models every time you run sails lift</td>
</tr>
</tbody>
</table>
<h3 id="how-auto-migrations-work">How auto-migrations work</h3>
<p>When you lift your Sails app in a development environment, the configured auto-migration strategy will run. </p>
<ul>
<li><p>If you are using migrate: &#39;safe&#39;, then nothing extra will happen at all. </p>
</li>
<li><p>If you are using drop or alter, Sails will load every record in your development database into memory, then drop and recreate the physical layer representation of the data (i.e. tables/collections/sets/etc.) This allows any breaking changes you&#39;ve made in your model definitions, like removing a uniqueness constraint, to be automatically applied to your development database. </p>
</li>
<li><p>As well if you are using alter, Sails will then attempt to re-seed the freshly generated tables/collections/sets with the records it saved earlier.</p>
</li>
</ul>
<h3 id="can-i-use-auto-migrations-in-production-">Can I use auto-migrations in production?</h3>
<p>The drop and alter auto-migration strategies in Sails exist as a feature for your convenience during development, and when running automated tests. They are not designed to be used with data you care about. Please take care to never use drop or alter with a production dataset. </p>
<p>As a failsafe, any time you lift your app in a production environment, Sails always uses migrate: &#39;safe&#39;, no matter what you have configured.</p>
<p>In many cases, hosting providers automatically set the NODE_ENV environment variable to &quot;production&quot; when they detect a Node.js app. Even so, please don&#39;t rely only on that failsafe, and take the usual precautions to keep your users&#39; data safe. </p>
<h3 id="set-migrate-strategy">Set Migrate Strategy</h3>
<h4 class="exercise-start">
    <b>Exercise</b>: Set Migrate Strategy
</h4>

<p>Since we are in development, we are going to use the alter strategy to have Sails keep our model in sync with our data store.  </p>
<ol>
<li>Open the config\models.js file</li>
<li><p>At the bottom of the file uncomment the migrate line</p>
<pre><code class="lang-javascript"> migrate: &#39;alter&#39;
</code></pre>
</li>
</ol>
<div class="exercise-end"></div>

				</div>
				<hr>
				<div class="chapter">
					<h2 id="overriding-built-in-rest-verbs">Overriding Built-In REST Verbs</h2>
<p>Up to this point we have been using all of the built-in REST function.  However, we are going to want to create our own function with our own business logic.  </p>
<p>Here is a short list of some of the business logic we will be creating:</p>
<ul>
<li>Validate that the email address is an actual email address</li>
<li>Encrypted the password</li>
<li>Remove the encrypted password from the returned json</li>
<li>Only allow a user to get, update and delete data that they own</li>
<li>Allow a user to signup </li>
<li>Allow a user to login</li>
<li>Allow a user to sign out
Be able to query to the current logged in user</li>
<li>Associate a user to a todo item</li>
<li>Store the logged in user in session state</li>
</ul>
<h3 id="function-map">Function Map</h3>
<p>To override the built-in get, post, put, and delete, we will be creating methods in the controller.  Below is the mapping of REST verbs to function names.</p>
<table>
<thead>
<tr>
<th>VERB</th>
<th>Method Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>POST</td>
<td>create</td>
<td>Insert new record</td>
</tr>
<tr>
<td>GET</td>
<td>find</td>
<td>Get all records</td>
</tr>
<tr>
<td>GET/:id</td>
<td>findOne</td>
<td>Get record by ID</td>
</tr>
<tr>
<td>PUT</td>
<td>update</td>
<td>Update record</td>
</tr>
<tr>
<td>DELETE</td>
<td>destroy</td>
<td>Remove record</td>
</tr>
</tbody>
</table>
<h3 id="function-format">Function Format</h3>
<p>The standard format of the sails controller function looks like the following with replacing <em>METHOD_NAME</em> with the method name from above.   </p>
<h4 class="exercise-start">
Function Format Example
</h4>

<pre><code class="lang-javascript">METHOD_NAME: function METHOD_NAMEFn(req, res) {
     // get body of the request
     var body = req.body; 

     // get id from either querystring or body
     var id = req.params.id; 
}
</code></pre>
<p>This format for the function is the same for the custom functions that we will be creating for logging in and logging out. </p>
<div class="exercise-end"></div> 


				</div>
				<hr>
				<div class="chapter">
					<h2 id="user-api-logic">User API Logic</h2>
<p>In this chapter we are going to add logic to allow a user to login, signup, logout, perform CRUD (<strong>C</strong>reate, <strong>R</strong>ead, <strong>U</strong>pdate, <strong>D</strong>elete) operations on the data that they own.</p>
<h3 id="sign-up">Sign up</h3>
<p>The first thing that we are going to do is override the POST verb with our own create function that will allow a user to signup for our Todo API.  Within the sign up function we will validate the email address is an actual email address, then encrypt the password before creating a user record in the data store and finally return back the newly created user.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Create Sign up Stub
</h4>

<p>For the sign up since we will be overriding the POST verb, we will be creating a function called create.</p>
<ol>
<li><p>Open the api\controllers\UserController.js file</p>
<pre><code class="lang-bash"> usercontroller.js
</code></pre>
 <div class="alert alert-info" role="alert">In Visual Studio Code, use Ctrl+P to bring up the find file dialog, paste in the file name, and either click on the file or arrow down to it and press enter</div>
</li>
<li><p>Within the module.exports add the following function stub to override the POST verb</p>
<pre><code class="lang-javascript"> create: function createFn(req, res){

 }
</code></pre>
 <div class="alert alert-info" role="alert">The function takes in 2 parameters:  req is the request and res is the response.</div>
</li>
<li><p>By creating the above method, Sails will automatically use this method for the POST verb without us having to do any route configurations.  It is using convention over configuration.</p>
</li>
</ol>
<div class="exercise-end"></div>


<h4 class="exercise-start">
    <b>Exercise</b>: Validate Email Address
</h4>

<p>The first thing we want to do when a user signs up is to validate that their email address is an actual email address.  It is good practice to re-validate the data that is coming into the API even if the UI is also doing validation.  To validate the email address, we are going to use <a href="http://node-machine.org/">Node Machines</a>. Each Node Machine has a single and clear purpose.</p>
<p>The only downside to using the machine packs is that you will have to use callbacks instead of promises within the Sails functions that we create that uses a machine pack.</p>
<p>Before we can use a Node Machine Pack we need to install the pack we want to use.  They are installed using NPM.    For email addresses, we are going to use the machinepack-emailaddresses.  </p>
<ol>
<li><p>Open the Visual Studio Code Integrated Terminal</p>
 <div class="alert alert-info" role="alert">ctrl+` to show the integrated terminal</div>
</li>
<li><p>Run the following command to install the machinepack-emailaddresses that will be used to validate the email address</p>
<pre><code class="lang-bash"> npm install --save machinepack-emailaddresses
</code></pre>
</li>
<li><p>You can do a ctrl+` to toggle off the integrated terminal</p>
</li>
<li><p>In the api\controllers\UserController.js file at the top outside of the module.exports, we need to import the machinepack-emailaddresses</p>
<pre><code class="lang-javascript"> var EmailAddresses = require(&#39;machinepack-emailaddresses&#39;);
</code></pre>
</li>
</ol>
<p>Within the create function we are ready to start adding in our logic.    </p>
<ol>
<li><p>Create a variable that gets the email address from the req parameters (body)</p>
<pre><code class="lang-javascript"> var email = req.param(&#39;email&#39;);
</code></pre>
</li>
<li><p>Call the EmailAddress.validate function to validate the email address and then check the results.  The Validate function has 3 possible returns:  error, invalid, and success. If there is an error we will return a server error (500 status code).  If the email is not valid then we will return a bad request (400 status code).  If the email is valid, then we will move on to encrypting the password. </p>
<pre><code class="lang-javascript">// validate the email address that is passed in
EmailAddresses.validate({
  string: email,
}).exec({
    // called if there is a general error
    error: function(err){
        return res.serverError(err);
    },

    // called if email is invalid
    invalid: function(){
        return res.badRequest(&#39;Does not look like an email address to me!&#39;);
    },

    // called if the email validation passed
    success: function(){
    }
});
</code></pre>
</li>
</ol>
<p>Within the success callback for the email validate we are ready to encrypt the password.  We will be using the machinepack-passwords to do the encryption and validating that the encrypted password and unencrypted passwords match.</p>
<ol>
<li><p>Open the Visual Studio Code Integrated Terminal</p>
 <div class="alert alert-info" role="alert">ctrl+` to show the integrated terminal</div>
</li>
<li><p>Install the machinepack-passwords</p>
<pre><code class="lang-bash"> npm install --save machinepack-passwords
</code></pre>
</li>
<li><p>At the top of the UserController, we need to add a require statement for the machinepack-passwords</p>
<pre><code class="lang-javascript"> var Passwords = require(&#39;machinepack-passwords&#39;);
</code></pre>
</li>
<li><p>Within the success callback for the email validate we need to call the Passwords.encryptPassword function and pass it the password from the request parameters (body).  The Passwords.encryptPassword function returns back 2 responses:  error or success.  If there is an error, we will return a server error (500 status code).  If it is successful, we will create the user in our data store.</p>
<pre><code class="lang-javascript"> // encrypt the password
 // get password from the body of the request with the req.param call
 Passwords.encryptPassword({
     password: req.param(&#39;password&#39;),
 }).exec({
     // if there is an error return a server error 500 status code
     error: function(err){
         return res.serverError(err);
     },

     // if success then move on to the next step
     success: function(result){
     }
 })
</code></pre>
</li>
</ol>
<p>Now we are ready to create our user in the data store and add the user to the request session.  Within the success callback add the following code to create a user with email and encryptedPassword fields.  We will get the email from the local variable that we created earlier and the encryptedPassword will come from the results of the Password.encryptPassword call.  To add the record to the data store, we are using the Waterline ORM and calling User.create.  Waterline allows us to write data store agnostic code.</p>
<ol>
<li><p>Within the success callback add the following code to create a local user variable</p>
<pre><code class="lang-javascript">// create user with email and encryptedPassword to add to the database
var user = {
    email: email,
    encryptedPassword: result
};
</code></pre>
</li>
<li><p>After the user variable declaration, call the Waterline ORM create function to create a new record based on the user variable that we created in the previous step </p>
<pre><code class="lang-javascript"> // User waterline to create a new user by calling .create and passing in the local user variable
 User.create(user, function (err, createdResult) {
     // check for errors
     if (err) return res.serverError(err);

     // add user id to session state
     req.session.user = createdResult.id;

     // return back created user with a status code of 200
     // see api\responses\ok.js for what the ok response is actually doing
     return res.ok(createdResult);
 });
</code></pre>
<ul>
<li><strong>Note:</strong> When we set the req.session.user was are only setting the id. This is so that the encryptedPassword hash does not end up in the in-memory session store.</li>
</ul>
</li>
</ol>
<h4 id="verify-sign-up-api">Verify Sign up API</h4>
<ol>
<li>In order to test the create function, we have to restart the sails lift.  Stop sails lift using ctrl+c and run sails lift </li>
<li><p>Now if you run the POST call against the User API, you will see if returns back a user with an encryptedPassword (<em>step 8</em>)</p>
<p> <img src="images/postman-user-custom-create.png" alt="Postman user custom create"></p>
</li>
</ol>
<div class="exercise-end"></div>

<h3 id="remove-password-from-json">Remove Password from JSON</h3>
<p>We now have users saved with an encrypted password but we are passing the encrypted hash as part of the returned user.  This is not a good security practice.  There is no reason to pass the encrypted password back from the API.  Luckily it is really easy to global remove this field anytime the user is serialized to JSON.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Stripping the encryptedPassword from JSON
</h4>

<ol>
<li><p>Open api\models\User.js</p>
<pre><code class="lang-bash"> user.js
</code></pre>
</li>
<li><p>Within the attributes we are going to create a function called toJSON</p>
<pre><code class="lang-javascript"> toJSON: function (){

 }
</code></pre>
</li>
<li><p>Within the toJSON function we need to get a reference to the current record by calling this.toObject() and setting the output a variable</p>
<pre><code class="lang-javascript"> var obj = this.toObject();
</code></pre>
</li>
<li><p>Now that we have a reference to the current record (object), we can call delete to remove the encryptedPassword field from the JSON results</p>
<pre><code class="lang-javascript"> delete obj.encryptedPassword;
</code></pre>
</li>
<li><p>The last thing left to do is return back the object</p>
<pre><code class="lang-javascript"> return obj;
</code></pre>
</li>
</ol>
<h4 id="verify-tojson-works">Verify toJSON Works</h4>
<ol>
<li>You must restart sails lift for the changes to take effect</li>
<li><p>Now if you run the GET call for the user, you will see that the encryptedPassword field is no longer returned back from the API</p>
<p> <img src="images/postman-user-without-encryptedPassword.png" alt="User Get without EncryptedPassword"></p>
</li>
</ol>
<div class="exercise-end"></div>

<h3 id="make-sure-email-is-unique">Make sure Email is unique</h3>
<p>We want to make sure that each user is unique and has not signed up already.  To enable this constraint we need to define the email field and add the unique attribute to the field.</p>
<p>Fields and attributes are defined within the model file in the attributes section.  Some of the common attributes are: required, type, unique, and defaultsTo.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Defining Email Field
</h4>

<ol>
<li><p>Within the already open api\models\user.js add the following attribute to the attributes section.  This will tell Sails that the email field is required, of type string, and needs to be unique.  For the unique attribute, it is actually run within the data store and not within the API. </p>
<pre><code class="lang-javascript"> email: {
     required: &#39;true&#39;,
     type: &#39;string&#39;,
     unique: true,
 },
</code></pre>
</li>
</ol>
<h4 id="verify-unique-attribute">Verify Unique Attribute</h4>
<ol>
<li>You must restart sails lift for the changes to take effect</li>
<li><p>If you now try to do a POST again for the user with the same email you will get an error that unique constraint was violated.  </p>
<p> <img src="images/email-unique-error.png" alt="Unique Error"></p>
</li>
</ol>
<div class="exercise-end"></div>

<h4 class="exercise-start">
    <b>Exercise</b>: Create a Custom Response
</h4>

<p>The default unique error is really ugly.  Instead we can check for the unique error and return our own response that contains an easier message to parse.  </p>
<ol>
<li><p>We need to replace the current error check in the User.create callback with the following code</p>
<pre><code class="lang-javascript"> if (err) {
     if (err.invalidAttributes
         &amp;&amp; err.invalidAttributes.email
         &amp;&amp; err.invalidAttributes.email[0]
         &amp;&amp; err.invalidAttributes.email[0].rule === &#39;unique&#39;) {
         return res.alreadyInUse(err);
     }

     return res.serverError(err);
 }
</code></pre>
</li>
</ol>
<p>In our error trapping we are not returning res.alreadyInUse when the unique constraint is fired.  We need to create this response before our code will work.</p>
<ol>
<li><p>On the api\responses folder, right-click on the folder, pick New File and name the file alreadyInUse.js</p>
<pre><code class="lang-bash"> alreadyInUse.js
</code></pre>
</li>
<li><p>The alreadyInUse response will return a response with a 409 status code and message of &quot;Email address is already taken by another user, please try again.&quot;   </p>
<pre><code class="lang-javascript"> module.exports = function alreadyInUse(err){
     // Get access to `res`
     // (since the arguments are up to us)
     var res = this.res;

     if (err.invalidAttributes.email) {
         return res.send(409, &#39;Email address is already taken by another user, please try again.&#39;);
     }
 };
</code></pre>
</li>
<li><p>By create the file in the response folder, the response is automatically wired up and available to use.</p>
</li>
</ol>
<h4 id="verify-custom-response">Verify Custom Response</h4>
<ol>
<li>You must restart sails lift for the changes to take effect</li>
<li><p>If you now try to do a POST again for the user with the same email you will get an error that looks much nicer than before and has a status code of 409.  You could also change the response message to be a standard format that the whole API will use instead of just plain text if you wanted to</p>
<p> <img src="images/already-in-use.png" alt="already in use response"></p>
</li>
</ol>
<div class="exercise-end"></div>

<h4 class="exercise-start">
    <b>Exercise</b>: Encrypted Password Field Definition
</h4>

<p>In the api\model\User.js file we are also going to define the encryptedPassword as well so that we have it later when we change over to a schema based data store like Postgres or MySql.  For the encryptedPassword field we are going to set it to be required and of type string. </p>
<ol>
<li><p>Open the api\models\User.js</p>
<pre><code class="lang-bash"> user.js
</code></pre>
</li>
<li><p>To the attributes add the encryptedPassword field</p>
<pre><code class="lang-javascript"> encryptedPassword: {
     required: &#39;true&#39;,
     type: &#39;string&#39;,
 },
</code></pre>
</li>
</ol>
<h4 id="verify-encryped-password-field-attributes">Verify Encryped Password Field Attributes</h4>
<ol>
<li>You must restart sails lift for the changes to take effect</li>
<li>Now you have to input a password when calling the sign up API and it must be a string.</li>
</ol>
<div class="exercise-end"></div>

<h3 id="login">Login</h3>
<p>You can&#39;t have a sign up without having a login to go with it.  The login function will pull the user from the data based on the email address, check if a record was found and if it was then verify that the password matched the encrypted password in the database.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Create the Login Function Stub
</h4>

<ol>
<li><p>Open the api\controllers\UserController.js</p>
<pre><code class="lang-bash"> UserController.js
</code></pre>
</li>
<li><p>We are going to add a function called login with the standard Sails controller function definition</p>
<pre><code class="lang-javascript"> login: function loginFn(req, res) {

 },
</code></pre>
</li>
<li><p>The first thing we are going to do is attempt to pull the user out of the database based on the email address.  We will be using the Waterline findOne function to ensure that we only pull back the 1 record.  We will get the email from req.param </p>
<pre><code class="lang-javascript"> User.findOne(
     { 
         email: req.param(&#39;email&#39;) 
     }, 
     function (err, result) {

     }
 )
</code></pre>
</li>
<li><p>In the callback function, we need to add our standard error check that will return back a server error if an error did occur</p>
<pre><code class="lang-javascript"> if (err) return res.serverError(err);
</code></pre>
</li>
<li><p>The next thing we want to check for is if the user was found or not.  If the user was not found then we want to return a 404 not found error</p>
<pre><code class="lang-javascript"> if (!result) return res.notFound();
</code></pre>
</li>
<li><p>If we found the user then we want to use the Node Machine password pack that we used earlier to validate that the unencrypted and encrypted passwords match.  The response from the machine pack will be either error, incorrect or success.  If there was an error we will return a server error.  If the password was incorrect we will return a forbidden error.  If it was success then we will add the session user and return the user.   </p>
<pre><code class="lang-javascript"> Passwords.checkPassword({
     passwordAttempt: req.param(&#39;password&#39;),
     encryptedPassword: result.encryptedPassword
 }).exec({
     error: function (err) {
         return res.serverError(err);
     },

     incorrect: function () {
         return res.forbidden(&#39;Invalid Login, Please Try Again!&#39;);
     },

     success: function () {
         req.session.user = result.id;

         return res.ok(result);
     }
 })
</code></pre>
<ul>
<li><strong>Note:</strong> When we set the req.session.user was are only setting the id. This is so that the encryptedPassword hash does not end up in the in-memory session store.</li>
</ul>
</li>
</ol>
<h4 id="verify-login-api">Verify Login API</h4>
<ol>
<li>You must restart sails lift for the changes to take effect</li>
<li>Open Postman</li>
<li>Set the REST verb to POST (<em>step 1</em>)</li>
<li><p>Set the URL to <a href="http://localhost:1337/user/login">http://localhost:1337/user/login</a> (<em>step 2</em>)</p>
<pre><code class="lang-bash"> http://localhost:1337/user/login
</code></pre>
</li>
<li><p>Click on the Body tab (<em>step 3</em>)</p>
</li>
<li>Select Raw (<em>step 4</em>)</li>
<li>Set the type to JSON (application/json) (<em>step 5</em>)</li>
<li><p>Set the body of the request to the following to pass in the email and password fields.  Change the email and password values as needed for the user that you created earlier with the sign up function (<em>step 6</em>)</p>
<pre><code class="lang-javascript"> {
     &quot;email&quot;: &quot;foo@foo.com&quot;,
     &quot;password&quot;: &quot;123456&quot;
 }
</code></pre>
</li>
<li><p>Click the Send button (<em>step 7</em>)</p>
</li>
<li>If everything worked you should now be logged and your user information was returned back to you (<em>step 8</em>) with a 200 status code (<em>step 9</em>).</li>
</ol>
<p><img src="images/postman-user-login.png" alt="already in use response"></p>
<div class="exercise-end"></div>

<h3 id="logout">Logout</h3>
<p>Now that we can either sign up or login to the API, we need to be able to log out of the API.  Logging out of the API in our case is really simple.  We are going to clear the req user session and return back a response ok (200 status code)</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Implement Logout Function
</h4>

<ol>
<li>Open the api\controllers\UserController.js</li>
<li><p>Add the logout function below to the existing functions</p>
<pre><code class="lang-javascript"> logout: function logoutFn(req, res) {
     req.session.user = null;

     return res.ok();
 },
</code></pre>
</li>
</ol>
<h4 id="verify-logout-api">Verify Logout API</h4>
<ol>
<li>You must restart sails lift for the changes to take effect</li>
<li>Open Postman</li>
<li>Set the verb to GET (<em>step 1</em>)</li>
<li><p>Set the url to <a href="http://localhost:1337/user/logout">http://localhost:1337/user/logout</a> (<em>step 2</em>)</p>
<pre><code class="lang-bash"> http://localhost:1337/user/logout
</code></pre>
</li>
<li><p>Click the send button (<em>step 4</em>)</p>
</li>
<li>You should get an empty response with a status code of 200 (<em>step 4</em>)</li>
</ol>
<p><img src="images/postman-user-logout.png" alt="Postman logout"></p>
<div class="exercise-end"></div>

<h3 id="who-is-logged-in-">Who is Logged In?</h3>
<h4 class="exercise-start">
    <b>Exercise</b>: Get Logged in User Info
</h4>

<ol>
<li><p>Open the api\controllers\UserController.js </p>
<pre><code class="lang-bash"> UserController.js
</code></pre>
</li>
<li><p>We are going to add a function called userIdentity</p>
<pre><code class="lang-javascript"> userIdentity: function (req, res) {
 },
</code></pre>
</li>
<li><p>Within the userIdentity function we are going to use the Waterline ORM find a single record in the data store by running findOne</p>
<ul>
<li>We will query by id againt the req.session.user</li>
<li>We will do the standard error trapping looking for errors and missing records.</li>
<li><p>If user was found then return an ok response</p>
<pre><code class="lang-javascript">User.findOne(
  { id: req.session.user }, 
  function (err, result) {
      if (err) return res.serverError(err);
      if (!result) return res.notFound();

      return res.ok(result);      
  }
);
</code></pre>
</li>
</ul>
</li>
</ol>
<h4 id="verify-user-identity-api">Verify User Identity API</h4>
<p>We can test the userIdentity API by making a GET call to <a href="http://localhost:1337/user/userIdentity">http://localhost:1337/user/userIdentity</a> after we have called the login API</p>
<ol>
<li>You must restart sails lift for the changes to take effect</li>
<li>Open Postman</li>
<li>Make a call to the login API like we did before so that we have a logged in user </li>
<li>Open another tab in Postman </li>
<li>Set the verb to GET (<em>step 1</em>)</li>
<li><p>Set the url to <a href="http://localhost:1337/user/userIdentity">http://localhost:1337/user/userIdentity</a> (<em>step 2</em>)</p>
<pre><code class="lang-bash"> http://localhost:1337/user/userIdentity
</code></pre>
</li>
<li><p>Click the Send Button (<em>step 3</em>)</p>
</li>
<li>You should see your user information returned (<em>step 4</em>) with a 200 status code (<em>step 5</em>)</li>
</ol>
<p><img src="images/postman-user-identity.png" alt="Postman User Identity"></p>
<div class="exercise-end"></div>

<h3 id="get-user-info">Get User Info</h3>
<p>Right now if you sign up a 2nd user and then do a GET on the user API,  you will be able to see both records.  This is not great from a privacy standpoint.  You should only be able to see your user information.  </p>
<p><img src="images/postman-user-show-all.png" alt="Postman Show All Users"></p>
<p>In order to restrict the data, we are going to override the find (get all) and findOne (get 1 record by id) functions to only return back the information for the logged in user.</p>
<p>Even though we will only ever be returning 1 record back, we want to use the find function which returns an array instead of the findOne that returns a single record.  This way we keep the expected return type of a GET all REST call which is an array of records.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Override Find Function
</h4>

<ol>
<li><p>Open api/controllers/UserController.js</p>
<pre><code class="lang-bash"> usercontroller.js
</code></pre>
</li>
<li><p>Add the following function stub to override the find function</p>
<pre><code class="lang-javascript"> find: function findFn(req, res) {

 },
</code></pre>
</li>
<li><p>Within the find function, we want to use Waterline to call the find function on the User object, filter by the user we have stored in session, and then have our standard callback to process the results</p>
<pre><code class="lang-javascript"> User.find(
     { id: req.session.user }, 
     function (err, results) {

     }
 );
</code></pre>
</li>
<li><p>Within the callback the first thing we want to do is check for errors</p>
<pre><code class="lang-javascript"> if (err) return res.serverError(err);
</code></pre>
</li>
<li><p>Then we want to check if the user was found or not.  Since the find method returns an array we can look at the length to determine if the record was returned.   If the record is not found, we will return a response notFound.</p>
<pre><code class="lang-javascript"> if (results.length === 0) return res.notFound();
</code></pre>
</li>
<li><p>The final thing we are going to do is return the user record that was found with a 200 status code.  </p>
<pre><code class="lang-javascript">return res.ok(results);
</code></pre>
</li>
</ol>
<h4 id="verify-find-override">Verify Find Override</h4>
<ol>
<li>You must restart sails lift for the changes to take effect</li>
<li>Open Postman</li>
<li>If you have not created a 2nd user, make a call the sign up API and create a 2nd user</li>
<li>If you have already created the 2nd user, then call the login API to login    </li>
<li>Open another tab in Postman </li>
<li>Set the verb to GET (<em>step 1</em>)</li>
<li><p>Set the url to <a href="http://localhost:1337/user">http://localhost:1337/user</a> (<em>step 2</em>)</p>
<pre><code class="lang-bash"> http://localhost:1337/user
</code></pre>
</li>
<li><p>Click the Send Button (<em>step 3</em>)</p>
</li>
<li>You should only see your user information returned (<em>step 4</em>) with a 200 status code (<em>step 5</em>)</li>
</ol>
<p><img src="images/postman-user-find.png" alt="Postman Find Override"></p>
<div class="exercise-end"></div>

<h4 class="exercise-start">
    <b>Exercise</b>: Find by Id Override
</h4>

<p>To override the find by get (<a href="http://localhost:1337/user/2">http://localhost:1337/user/2</a>) we need to override the findOne function.  The findOne is similar to the find that we just created except that we will only be returning a single record back instead of an array with 1 record.</p>
<p>In the api/user/usercontroller.js add the following function that will call the Waterline findOne function on the User object, filtering by the id stored in request session and then running our standard error checks before return back the user record.</p>
<pre><code class="lang-javascript">findOne: function findOneFn(req, res) {
    User.findOne(
        { id: req.session.user }, 
        function (err, result) {
            if (err) return res.serverError(err);
            if (!result) return res.notFound();

            return res.ok(result);
        }
    );
},
</code></pre>
<h4 id="verify-find-by-id-override">Verify Find by Id Override</h4>
<ol>
<li>You must restart sails lift for the changes to take effect</li>
<li>Open Postman</li>
<li>Call the login API to login    </li>
<li>Open another tab in Postman </li>
<li>Set the verb to GET (<em>step 1</em>)</li>
<li><p>Set the url to <a href="http://localhost:1337/user/2">http://localhost:1337/user/2</a> (<em>step 2</em>)</p>
<pre><code class="lang-bash"> http://localhost:1337/user/2
</code></pre>
<ul>
<li><p>The 2 at the end of the url is the Id field value for the user record.</p>
<div class="alert alert-info"><strong>Note</strong> You can technically use any value as long as it is not a route name since we are getting the Id from the req.session.user and not from the querystring.</div>
</li>
</ul>
</li>
<li><p>Click the Send Button (<em>step 3</em>)</p>
</li>
<li>You should only see your user information returned (<em>step 4</em>) with a 200 status code (<em>step 5</em>)</li>
</ol>
<p><img src="images/postman-user-findOne.png" alt="Postman Find Override"></p>
<div class="exercise-end"></div>

<h3 id="update-user">Update User</h3>
<p>The next thing we are going to do is override the update function so that we can only update our own user.</p>
<p>We will allow the user to change their email and password.  We need to make sure to valid that email address and encrypt the password.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Create Update Function
</h4>

<ol>
<li><p>Open the api/models/UserController.js</p>
<pre><code class="lang-bash"> UserController.js
</code></pre>
</li>
<li><p>Create the update function stub</p>
<pre><code class="lang-javascript"> update: function updateFn(req, res){

 },
</code></pre>
</li>
<li><p>Within the update function we want to use the Node Machine email pack to validate the email address like we did in the create function</p>
<pre><code class="lang-javascript"> EmailAddresses.validate({
   string: req.param(&#39;email&#39;),
 }).exec({
   error: function (err) {
     return res.serverError(err);
   },

   invalid: function () {
     return res.badRequest(&#39;Does not look like an email address to me!&#39;);
   },

   success: function () {

   },
 });
</code></pre>
</li>
<li><p>If the email address is validate we want to encrypt the password like we did before with the Node Machine pack passwords</p>
<pre><code class="lang-javascript"> Passwords.encryptPassword({
     password: req.param(&#39;password&#39;),
 }).exec({
     error: function(err){
     return res.serverError(err);
     },

     success: function(result){

     },
 });
</code></pre>
</li>
<li><p>Lastly, in the success of the encrypt response, we want to update the user record in the data store and return back the results.</p>
<pre><code class="lang-javascript"> var user = {
     email: req.param(&#39;email&#39;),
     encryptedPassword: result,
 }
 User.update(
     { id: req.session.user },
     user,
     function (err, result) {
     if (err) return res.serverError(err);
     if (results.length === 0) return res.notFound();

     return res.ok(result);
     }
 );
</code></pre>
 <div class="alert alert-info" role="alert"><strong>Note:</strong> The Waterline update call returns an array of records.</div>

</li>
</ol>
<h4 id="verify-update-override">Verify Update Override</h4>
<ol>
<li>You must restart sails lift for the changes to take effect</li>
<li>Open Postman</li>
<li>Call the login API to login    </li>
<li>Open another tab in Postman </li>
<li><p>Set the verb to PUT (<em>step 1</em>)</p>
 <div class="alert alert-info" role="alert">PUT is the REST verb for doing an update</div>
</li>
<li><p>Set the url to <a href="http://localhost:1337/user/2">http://localhost:1337/user/2</a> (<em>step 2</em>)</p>
<pre><code class="lang-bash"> http://localhost:1337/user/2
</code></pre>
<ul>
<li><p>The 2 at the end of the url is the Id field value for the user record.</p>
<div class="alert alert-info"><strong>Note</strong> You can technically use any value as long as it is not a route name since we are getting the Id from the req.session.user and not from the querystring.</div>
</li>
</ul>
</li>
<li><p>Click on the Body tab (<em>step 3</em>)</p>
</li>
<li>Select Raw (<em>step 4</em>)</li>
<li>Set the type to JSON (application/json) (<em>step 5</em>)</li>
<li><p>Set the body of the request to the following to pass in the email and password fields.  Change the email and password values (<em>step 6</em>)</p>
<pre><code class="lang-javascript"> {
     &quot;email&quot;: &quot;foo2@foo.com&quot;,
     &quot;password&quot;: &quot;1234567&quot;
 }
</code></pre>
</li>
<li><p>Click the Send button (<em>step 7</em>)</p>
</li>
<li>If everything worked you should now be logged and your user information was returned back to you (<em>step 8</em>) with a 200 status code (<em>step 9</em>).</li>
</ol>
<p><img src="images/postman-user-update.png" alt="Postman Find Override"></p>
<div class="alert alert-danger" role="alert">If you try to login in with the original email, you should get a 404 not found error</div>
<div class="alert alert-danger" role="alert">If you try to login with the original password, you should get a 403 Forbidden status with an &quot;Invalid Login, Please Try Again!&quot; message
</div>

<div class="exercise-end"></div>

<h3 id="delete-user">Delete User</h3>
<p>The last thing that we are going to do is to override the delete function to ensure that we can only delete our own user.</p>
<p>The user must be logged in before they can be deleted.  </p>
<h4 class="exercise-start">
    <b>Exercise</b>: 
</h4>

<p>We will call the Waterline delete function on the User object and make sure to filter it by the user id that is stored in req.session.user.  We will then do our standard error traping and return back the result.  We will also clear out the req.session.user since we are deleting the user and we want to make sure that they are actually logged out of the API.</p>
<p>Even though we are deleting the user we will return back the record that we just deleted.  This way we keep with the way the Sails does it out of the box.</p>
<ol>
<li><p>Open the api/controllers/UserController.js</p>
<pre><code class="lang-bash"> UserController.js
</code></pre>
</li>
<li><p>Add the following function for the delete call</p>
<pre><code class="lang-javascript"> delete: function deleteFn(req, res) {
     User.delete(
         {
         id: req.session.user
         }
     ), function (err, result) {
         if (err) return res.serverError(err);
         if (!result) return res.notFound();

         req.session.user = null;
         return res.ok(result);
     }
 }
</code></pre>
</li>
</ol>
<h4 id="verify-delete-override">Verify Delete Override</h4>
<ol>
<li>You must restart sails lift for the changes to take effect</li>
<li>Open Postman</li>
<li>Call the login API to login    </li>
<li>Open another tab in Postman </li>
<li><p>Set the verb to DELETE (<em>step 1</em>)</p>
 <div class="alert alert-info" role="alert">PUT is the REST verb for doing an update</div>
</li>
<li><p>Set the url to <a href="http://localhost:1337/user/2">http://localhost:1337/user/2</a> (<em>step 2</em>)</p>
<pre><code class="lang-bash"> http://localhost:1337/user/2
</code></pre>
<ul>
<li><p>The 2 at the end of the url is the Id field value for the user record.</p>
<div class="alert alert-info"><strong>Note</strong> You can technically use any value as long as it is not a route name since we are getting the Id from the req.session.user and not from the querystring.</div>
</li>
</ul>
</li>
<li><p>Click the Send button (<em>step 3</em>)</p>
</li>
<li>If everything worked you should now be logged and your user information was returned back to you (<em>step 4</em>) with a 200 status code (<em>step 5</em>).</li>
</ol>
<p><img src="images/postman-user-delete.png" alt="Postman Find Override"></p>
<div class="exercise-end"></div>

<p>We have now completed the initial functionality for our User API.  Next we will configure our security policies so that we do not have to remember to login before running any of the function.</p>

				</div>
				<hr>
				<div class="chapter">
					<h2 id="locking-down-the-api">Locking Down the Api</h2>
<p>Update to this point you have had to remember to call the Login or Signup routes before you can see or update Todo items.  It would be much better if we directed users with errors messages that tell them that they need to perform an authentication call before trying to make a call.  </p>
<p>In order to do the authentication checks, Sails uses policies to lock down routes.  A policy is essential a function that returns a true/false value for whatever check you need to do.  </p>
<p>Policies are stored in the api\policies directory.  By creating a file in  the policies directory, they are automatically ready to be used to lock down a route.  </p>
<p>We will be creating 2 policies:  </p>
<ol>
<li>Check if you are logged in  </li>
<li>Check if you are logged out</li>
</ol>
<h3 id="policy-to-check-if-logged-in">Policy to Check if Logged In</h3>
<h4 class="exercise-start">
    <b>Exercise</b>: Create Is Logged In Policy
</h4>

<ol>
<li><p>In the api\policies folder, create a new JavaScript file called isLoggedIn.js</p>
<pre><code class="lang-bash"> isLoggedIn.js
</code></pre>
</li>
<li><p>The function format for Sails policies as follows.  It takes in a request, response, and next option.  </p>
<pre><code class="lang-javascript"> module.exports = function(req, res, next) {

 }
</code></pre>
</li>
<li><p>Within the policy function, we will use the req.session.user to determine if the user has logged in yet or not.  If the user has logged in, we need call next to go to the next policy in the chain.  If the user has not logged in, we will return the forbidden response.</p>
<pre><code class="lang-javascript"> if (req.session.user) {
     return next();
 }

 return res.forbidden(&#39;Please Login First.&#39;);
</code></pre>
</li>
</ol>
<div class="exercise-end"></div>

<h3 id="policy-to-check-if-logged-out">Policy to Check if Logged Out</h3>
<h4 class="exercise-start">
    <b>Exercise</b>: Create Is Logged Out Policy
</h4>

<ol>
<li><p>In the api\policies folder, create a new JavaScript file called isLoggedOut.js</p>
<pre><code class="lang-bash"> isLoggedOut.js
</code></pre>
</li>
<li><p>Remember that the function format for Sails policies as follows.  It takes in a request, response, and next option.  </p>
<pre><code class="lang-javascript"> module.exports = function(req, res, next) {

 }
</code></pre>
</li>
<li><p>Within the policy function, we will use the req.session.user to determine if the user has logged in yet or not.  If the user has not logged in, we will call to go to the next policy in the chain. If the user has logged in, we will return the forbidden response.  </p>
<pre><code class="lang-javascript"> if (!req.session.user) {
     return next();
 }

 return res.forbidden(&#39;Please Logout First&#39;);
</code></pre>
</li>
</ol>
<div class="exercise-end"></div>

<h3 id="locking-down-routes">Locking Down Routes</h3>
<p>Now that we have both of our policies created, we need to configure which routes will use which policy.  </p>
<table>
<thead>
<tr>
<th>Controller</th>
<th>Function</th>
<th>Policy</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>UserController</td>
<td>login</td>
<td>true</td>
<td>Let everyone make a call to login</td>
</tr>
<tr>
<td>UserController</td>
<td>create</td>
<td>[&#39;isLoggedOut&#39;]</td>
<td>Make sure that you are logged out before trying to login again</td>
</tr>
<tr>
<td>UserController</td>
<td>*</td>
<td>[&#39;isLoggedIn&#39;]</td>
<td>All routes that aren&#39;t already configured will use this policy chain</td>
</tr>
<tr>
<td>TodoController</td>
<td>*</td>
<td>[&#39;isLoggedIn&#39;]</td>
<td>All routes in Todo controller will use this policy</td>
</tr>
</tbody>
</table>
<h4 class="exercise-start">
    <b>Exercise</b>: Locking Down Routes
</h4>

<ol>
<li><p>Open config\policies.js</p>
<pre><code class="lang-bash"> policies.js
</code></pre>
</li>
<li><p>Within the module.exports.policies, add the following to the list of models that are locked down</p>
<pre><code class="lang-JavaScript"> UserController: {
     &#39;login&#39;: true,
     &#39;create&#39;: [&#39;isLoggedOut&#39;],
     &#39;*&#39;: [&#39;isLoggedIn&#39;]
 },
 TodoController: {
     &#39;*&#39;: [&#39;isLoggedIn&#39;]
 }
</code></pre>
</li>
</ol>
<div class="exercise-end"></div>

<h3 id="verify-the-policies-are-working">Verify The Policies Are Working</h3>
<p>We are now ready to test that our security is working.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Testing policy
</h4>

<ol>
<li><p>Restart sails lift.  If you already have sails lift running, you need to ctrl+c to stop running it and restart it.  Policies do not automatically up themselves as you change the code until sails lift is restarted.</p>
</li>
<li><p>For the User routes, if you try to do any call besides a POST, you will get a message that you need to login first</p>
<p> <img src="images/postman-policy-login.png" alt="Not Logged In User Message"> </p>
</li>
<li><p>For the Todo routes, if you try to do any call you will get a message that you need to login first.  Even though we have not created any custom routes all of the standards REST verbs are already wired up</p>
<p> <img src="images/postman-policy-login.png" alt="Not Logged In User Message"> </p>
</li>
<li><p>Once you call the login route you will be able to do the following:</p>
<ul>
<li>For User routes, you will be able to do call all of the routes except the create new user.  </li>
<li>For Todo routes, you will be able to call all routes</li>
</ul>
</li>
<li><p>After you have logged in, if you try to create a user you will get an error message that you need to logout first. </p>
<p> <img src="images/postman-policy-logout.png" alt="Must Logout First Message"></p>
</li>
</ol>
<div class="exercise-end"></div>

				</div>
				<hr>
				<div class="chapter">
					<h2 id="routing">Routing</h2>
<p>As you create your own methods there are times where you want the route to be different from the function name in the controller.  </p>
<p>For example, in our UserController, we created a userIdentity function but having the route be /user/userIdentity is not very REST like.  Instead it would be better if could change the route to be /user/identity</p>
<p>All of the routes are configured in the config\routes.js file.  </p>
<h3 id="change-useridentity-route">Change userIdentity Route</h3>
<h4 class="exercise-start">
    <b>Exercise</b>: Create User Identity Route
</h4>

<ol>
<li><p>Open the config/routes.js</p>
<pre><code class="lang-bash"> routes.js
</code></pre>
</li>
<li><p>Within the module.exports.routes, add the following route that will setup a GET call at /user/identity that maps to the UserController userIdentity function.</p>
<pre><code class="lang-javascript"> &#39;GET /user/identity&#39;: &#39;UserController.userIdentity&#39;
</code></pre>
</li>
</ol>
<h3 id="verify-route-works">Verify Route Works</h3>
<ol>
<li>For the route to take effect you will need to stop the <code>sails lift</code> with a ctrl+c and then re-run the <code>sails lift</code></li>
<li>Open Postman</li>
<li>Make a call to the user login API</li>
<li>Set the verb to be GET (<em>step 1</em>)</li>
<li><p>Set the url to be <a href="http://localhost:1337/user/identity">http://localhost:1337/user/identity</a> (<em>step 2</em>)</p>
<pre><code class="lang-bash"> http://localhost:1337/user/identity
</code></pre>
</li>
<li><p>Click the Send button (<em>step 3</em>)</p>
</li>
<li>You should now see the user information for the logged in user (<em>step 4</em>) and a status code of 200 (<em>step 5</em>)</li>
</ol>
<p><img src="images/postman-route-user-identity.png" alt="User Identity Route Output"></p>
<div class="exercise-end"></div>

				</div>
				<hr>
				<div class="chapter">
					<h2 id="todo-api-logic">Todo API Logic</h2>
<p>So far we have not done anything with the Todo API.  That is about to change though.  We are going to add the following functionality to the Todo API.</p>
<ul>
<li>Associate a Todo record to a User Record in a 1:Many setting (e.g. a User will have many Todo records and a Todo Record will have 1 user)</li>
<li>Get the associated user from the req.session.user </li>
<li>Set completed for a new record to false by default</li>
<li>Make sure that for viewing, updating and deleting the a user can only affect their records</li>
</ul>
<h3 id="associating-user-to-todo-items">Associating User to Todo Items</h3>
<p>We could just put the User id into the Todo record but that would not actually associate the data.  By creating an actual association we will be able to also include the associated user record with the Todo recrod.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Associate Models
</h4>

<ol>
<li><p>Open api\models\Todo.js</p>
<pre><code class="lang-bash"> todo.js
</code></pre>
</li>
<li><p>In the attributes section add the following attribute to create a field that has an association to the User model.</p>
<pre><code class="lang-javascript"> user: {
   model: &#39;user&#39;
 }
</code></pre>
</li>
<li><p>Save the file</p>
</li>
</ol>
<p>We are now going to add the reverse associate so that the user model can get a list of associated Todo records. </p>
<ol>
<li><p>Open api\models\User.js</p>
<pre><code class="lang-bash"> User.js
</code></pre>
</li>
<li><p>To the attributes section, we need to add the following field that says it will be a collection of Todo records and associated through the User field that we created in the previous steps.</p>
<pre><code class="lang-javascript"> todoItems: {
   collection: &#39;todo&#39;,
   via: &#39;user&#39;
 },
</code></pre>
</li>
<li><p>Save the file</p>
</li>
</ol>
<div class="exercise-end"></div>

<h3 id="create-todo">Create Todo</h3>
<p>We are now going to setup the ability to create Todo items that gets the user for the res.session.user and sets completed to false by default.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Setup Model Field Attributes
</h4>

<ol>
<li><p>Open api\models\Todo.js</p>
<pre><code class="lang-bash"> todo.js
</code></pre>
</li>
<li><p>In the attributes we need to add the completed field.  We are going to make the field required, of type boolean, and defaults to false.</p>
<pre><code class="lang-javascript">completed: {
    required: &#39;true&#39;,
    type: &#39;boolean&#39;,
    defaultsTo: &#39;false&#39;
},
</code></pre>
</li>
</ol>
<p>While we are defining fields, lets go ahead and define our item field that will hold the text for our todo item.  The item field will be required and of type string.</p>
<p>In the attributes for the Todo model, add the item field below</p>
<pre><code class="lang-javascript">item: {
    required: &#39;true&#39;,
    type: &#39;string&#39;
},
</code></pre>
<div class="exercise-end"></div>

<h4 class="exercise-start">
    <b>Exercise</b>: Create Todo
</h4>

<p>Now that we have our fields defined, we are ready to override the POST verb with out own logic.  We wil get the item text from the body of the request and the user from the req.session.user.  We do not need to include the completed field since it will automatically default to true.</p>
<ol>
<li><p>Open api/controllers/TodoController.js</p>
<pre><code class="lang-bash"> TodoController.js
</code></pre>
</li>
<li><p>Add our create method stub to the module.exports</p>
<pre><code class="lang-javascript"> create: function createFn(req, res){

 }
</code></pre>
</li>
<li><p>Within the create function, we need to create a variable to hold the todo object we will be creating with the item and user fields populated.  The item field we will get from the request params collection and the user field from req.session.user.</p>
<pre><code class="lang-javascript"> var todo = {
     item: req.param(&#39;item&#39;),
     user: req.session.user
 };
</code></pre>
</li>
<li><p>Next we need to call the Todo model&#39;s create function and pass in the todo object we just created.  Then we will run our standard callback error check and return statement</p>
<pre><code class="lang-javascript"> Todo.create(todo, function (err, results) {
     if (err) res.serverError(err);

     return res.ok(results);
 });
</code></pre>
</li>
<li><p>Save the TodoController.js file</p>
</li>
</ol>
<h4 id="verify-todo-create">Verify Todo Create</h4>
<ol>
<li>Restart sails for the changes to take effect</li>
<li>Open Postman</li>
<li>Make a call to the user login API</li>
<li>Set the REST verb to POST (<em>step 1</em>)</li>
<li><p>Set the URL to <a href="http://localhost:1337/todo">http://localhost:1337/todo</a> (<em>step 2</em>)</p>
<pre><code class="lang-bash"> http://localhost:1337/todo
</code></pre>
</li>
<li><p>Click on the Body tab (<em>step 3</em>)</p>
</li>
<li>Select Raw (<em>step 4</em>)</li>
<li>Set the type to JSON (application/json) (<em>step 5</em>)</li>
<li><p>Set the body of the request to the following to pass in the email and password fields.  Change the email and password values as needed for the user that you created earlier with the sign up function (<em>step 6</em>)</p>
<pre><code class="lang-javascript"> {
     &quot;item&quot;: &quot;Coding with @digitaldrummerj and SailsJS&quot;
 }
</code></pre>
</li>
<li><p>Click the Send button (<em>step 7</em>)</p>
</li>
<li><p>If everything worked a new todo record was created and was returned back to you (<em>step 8</em>) with a 200 status code (<em>step 9</em>).</p>
<p> <img src="images/postman-todo-create.png" alt="create response"></p>
</li>
<li><p>You can verify that the create actually did work by running a GET against <a href="http://localhost:1337/todo">http://localhost:1337/todo</a></p>
<pre><code class="lang-bash"> http://localhost:1337/todo
</code></pre>
</li>
</ol>
<div class="exercise-end"></div>

<h3 id="get-todo-list">Get Todo List</h3>
<p>Next we want to be able to get back the Todo records that belong to us.  Right now we can pull all of the Todo records even if we do not own them.  To fix this issue, we are going to override the find function to filter it by the user field. </p>
<div class="alert alert-danger" role="alert"><strong>Note:</strong> That once we override the find function it will no longer by default return the associated user records.  Instead if will just returned the user Id value.  To fix this you have to make a call to populate and tell it which association to populate.</div>

<h4 class="exercise-start">
    <b>Exercise</b>: Get Todo List
</h4> 

<ol>
<li><p>Open api\controllers\TodoController.js</p>
<pre><code class="lang-bash"> TodoController.js
</code></pre>
</li>
<li><p>Within the module.exports, add the following function.  This function is just like we did for the override of the find function in the UserController with the addition of the populate users call.</p>
<pre><code class="lang-javascript"> find: function findFn(req, res) {
     Todo.find(
         { 
             user: req.session.user 
         }
     )
     .populate(&#39;user&#39;)
     .exec(function (err, results) {
         if (err) return res.serverError(err);
         if (results.length === 0) return res.notFound();

         return res.ok(results);
     });
 },
</code></pre>
</li>
<li><p>Save the TodoController.js</p>
</li>
</ol>
<h4 id="verify-the-find-function">Verify the Find Function</h4>
<ol>
<li>You must restart sails lift for the changes to take effect</li>
<li>Open Postman</li>
<li>Make sure to call the login API</li>
<li>Open another tab in Postman </li>
<li>Set the verb to GET (<em>step 1</em>)</li>
<li><p>Set the url to <a href="http://localhost:1337/todo">http://localhost:1337/todo</a> (<em>step 2</em>)</p>
<pre><code class="lang-bash"> http://localhost:1337/todo
</code></pre>
</li>
<li><p>Click the Send Button (<em>step 3</em>)</p>
</li>
<li>You should only see your user information returned (<em>step 4</em>) with a 200 status code (<em>step 5</em>)</li>
</ol>
<p><img src="images/postman-todo-find.png" alt="Postman Find Override"></p>
<div class="exercise-end"></div>

<h3 id="get-single-todo">Get Single Todo</h3>
<p>Just like with the find all, we can also see any individual todo record regardless if we own it or not.  To fix this we need to override the findOne function.  </p>
<div class="alert alert-danger" role="alert"><strong>Note:</strong> Just like the find function, the automatic population of associations goes away when we override the find function.  To fix this you have to make a call to populate and tell it which association to populate.</div>

<h4 class="exercise-start">
    <b>Exercise</b>: Find Single Todo Item
</h4>

<ol>
<li><p>Open api\controllers\TodoController.js</p>
<pre><code class="lang-bash"> TodoController.js
</code></pre>
</li>
<li><p>Add the following function to override the findOne function to make sure that we own the record, populate the user association, and then run our standard error trap/return statement.</p>
<pre><code class="lang-javascript"> findOne: function findOneFn(req, res) {
     Todo.findOne(
         { 
             user: req.session.user 
         }
     )
     .populate(&#39;user&#39;)
     .exec(function (err, result) {
         if (err) return res.serverError(err);
         if (!result) return res.notFound();

         return res.ok(result);
     });
 }
</code></pre>
</li>
<li><p>Save the file</p>
</li>
</ol>
<h4 id="verify-the-find-one-function">Verify the Find One Function</h4>
<ol>
<li>You must restart sails lift for the changes to take effect</li>
<li>Open Postman</li>
<li>Make sure to call the login API</li>
<li>Open another tab in Postman </li>
<li>Set the verb to GET (<em>step 1</em>)</li>
<li><p>Set the url to <a href="http://localhost:1337/todo/1">http://localhost:1337/todo/1</a> (<em>step 2</em>)</p>
<pre><code class="lang-bash"> http://localhost:1337/todo/1
</code></pre>
 <div class="alert alert-info">The 1 at the end of the url is the Id (primary key) value of the Todo record that we want to pull.  If the Id field for the Todo record you created is not 1, then change the value in the url.</div>
</li>
<li><p>Click the Send Button (<em>step 3</em>)</p>
</li>
<li>You should only see your user information returned (<em>step 4</em>) with a 200 status code (<em>step 5</em>)</li>
</ol>
<p><img src="images/postman-todo-findone.png" alt="Postman Find One Override"></p>
<div class="exercise-end"></div>

<h3 id="update-todo">Update Todo</h3>
<p>A Todo API wouldn&#39;t be complete without the ability to mark off the you completed an item.  However, we need to ensure that the user actually owns the record before we update it.  Up to this point, we have only used 1 parameter in our Waterline calls.  For the Update statement, we are going to use 2 parameters:  todo record id and the user value from req.session.user.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Update Single Todo
</h4>

<ol>
<li><p>Open api\controllers\TodoController.js</p>
<pre><code class="lang-bash"> TodoController.js
</code></pre>
</li>
<li><p>Add the following function stub to the module.exports</p>
<pre><code class="lang-javascript"> update: function (req, res) {

 },
</code></pre>
</li>
<li><p>Within the update function, create a variable called record that will hold the values that we plan on updating.</p>
<pre><code class="lang-javascript"> var record = {
     id: req.param(&#39;id&#39;),
     completed: req.param(&#39;completed&#39;),
     user: req.session.user
 };
</code></pre>
</li>
<li><p>Then we need to make a call to the Waterline update function on the Todo object and then run our normal error check and return statements.   If we do not get a record back, then we will assume that we don&#39;t own the record and return a not found error.</p>
<pre><code class="lang-javascript"> Todo.update(
     {
         user: req.session.user,
         id: req.param(&#39;id&#39;)
     }, 
     record,
     function (err, results) {
         if (err) res.serverError(err);
         if (results.length === 0) return res.notFound();

         return res.ok(results);
     }
 );
</code></pre>
</li>
</ol>
<div class="alert alert-warning"><strong>Note:</strong> The update statement returns back an array of records even though we are updating just one record.  Hence the length check in the callback function to make sure we have records</div>

<h4 id="verify-update-function">Verify Update Function</h4>
<ol>
<li>Restart sails for the changes to take effect</li>
<li>Open Postman</li>
<li>Make a call to the user login API</li>
<li>Set the REST verb to POST (<em>step 1</em>)</li>
<li><p>Set the URL to <a href="http://localhost:1337/todo/1">http://localhost:1337/todo/1</a> (<em>step 2</em>)</p>
<pre><code class="lang-bash"> http://localhost:1337/todo/1
</code></pre>
</li>
<li><p>Click on the Body tab (<em>step 3</em>)</p>
</li>
<li>Select Raw (<em>step 4</em>)</li>
<li>Set the type to JSON (application/json) (<em>step 5</em>)</li>
<li><p>Set the body of the request to the following to pass in the email and password fields.  Change the email and password values as needed for the user that you created earlier with the sign up function (<em>step 6</em>)</p>
<pre><code class="lang-javascript"> {
     &quot;item&quot;: &quot;Verify Coding with @digitaldrummerj and SailsJS&quot;,
     &quot;completed&quot;: true
 }
</code></pre>
</li>
<li><p>Click the Send button (<em>step 7</em>)</p>
</li>
<li><p>If everything worked a new todo record was created and was returned back to you (<em>step 8</em>) with a 200 status code (<em>step 9</em>).</p>
<p> <img src="images/postman-todo-update.png" alt="update response"></p>
</li>
<li><p>You can verify that the update actually did work by running a GET against <a href="http://localhost:1337/todo">http://localhost:1337/todo</a></p>
<pre><code class="lang-bash"> http://localhost:1337/todo
</code></pre>
</li>
</ol>
<div class="exercise-end"></div>

<h3 id="delete-todo">Delete Todo</h3>
<p>The last major thing we need to do it to override the delete function to make sure we can only delete record that we own.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Delete Single Todo
</h4>

<ol>
<li><p>Open api\controllers\TodoController.js</p>
<pre><code class="lang-bash"> TodoController.js
</code></pre>
</li>
<li><p>The delete function is like the other function that we have been overriding.  We are going to take in the Id of the record to delete, make sure we own it and then run our standard error/response check.</p>
<pre><code class="lang-javascript"> delete: function (req, res) {
     Todo.delete(
         { 
             user: req.session.user, 
             id: req.param(&#39;id&#39;),
         }, 
         function (err, results) {
             if (err) res.serverError(err);
             if (!results) return res.notFound();
             return res.ok(results);
         }
     );
 },
</code></pre>
</li>
</ol>
<h4 id="verify-delete-function">Verify Delete Function</h4>
<ol>
<li>Restart sails for the changes to take effect</li>
<li>Open Postman</li>
<li>Make a call to the user login API</li>
<li>Set the REST verb to POST (<em>step 1</em>)</li>
<li><p>Set the URL to <a href="http://localhost:1337/todo/1">http://localhost:1337/todo/1</a> (<em>step 2</em>)</p>
<pre><code class="lang-bash"> http://localhost:1337/todo/1
</code></pre>
</li>
<li><p>Click the Send button (<em>step 3</em>)</p>
</li>
<li><p>If everything worked a new todo record was created and was returned back to you (<em>step 4</em>) with a 200 status code (<em>step 5</em>).</p>
<p> <img src="images/postman-todo-delete.png" alt="delete response"></p>
</li>
<li><p>You can verify that the delete actually did work by running a GET against <a href="http://localhost:1337/todo">http://localhost:1337/todo</a></p>
<pre><code class="lang-bash"> http://localhost:1337/todo
</code></pre>
</li>
</ol>
<div class="exercise-end"></div>

				</div>
				<hr>
				<div class="chapter">
					<h2 id="deploying">Deploying</h2>
<h3 id="preparing-for-production">Preparing for Production</h3>
<p><a href="http://sailsjs.com/documentation/concepts/deployment">http://sailsjs.com/documentation/concepts/deployment</a></p>
<h3 id="deploy-to-heroku">Deploy to Heroku</h3>
<p>Prerequisites:</p>
<ul>
<li><a href="http://git-scm.com/">Git</a></li>
<li><a href="https://signup.heroku.com/login">Heroku account</a></li>
<li><a href="https://toolbelt.heroku.com/">Heroku Toolbelt installed</a> (CLI tool for creating and managing Heroku apps)</li>
</ul>
<h4 class="exercise-start">
    <b>Exercise</b>: Create Heroku App
</h4>

<ol>
<li>Stop sails lift</li>
<li>Open a command prompt or Windows terminal outside of Visual Studio Code</li>
<li>Navigate to our Sails app</li>
<li><p>Login to your Heroku account</p>
<pre><code class="lang-bash"> heroku login
</code></pre>
<p> <div class="alert alert-warning">If heroku can&#39;t be found, you will need to hit the trash in the upper right of your integrated shell and then open the integrated terminal up again<div></p>
</li>
<li><p>Create a new heroku app</p>
<pre><code class="lang-bash"> heroku create your-app-name
</code></pre>
</li>
<li><p>Next we need to create a ProcFile in the root of our project to tell Heroku how to run our Sails app</p>
<pre><code class="lang-bash"> Procfile
</code></pre>
</li>
<li><p>In the Procfile, add the following line</p>
<pre><code class="lang-bash"> web: node app.js
</code></pre>
</li>
<li><p>We need create a Git repository for our Sails ap</p>
<pre><code class="lang-bash"> git init
</code></pre>
</li>
<li><p>We are going to use Git on Heroku to do a deploy to Heroku</p>
<pre><code class="lang-bash"> heroku git:remote -a your-app-name
</code></pre>
</li>
<li><p>Add the Procfile to Git</p>
<pre><code class="lang-bash"> git add .
</code></pre>
</li>
<li><p>Now we need to commit the Procfile</p>
<pre><code class="lang-bash"> git commit -m &quot;initial commit with Procfile&quot;
</code></pre>
</li>
<li><p>We need to push to heroku</p>
<pre><code class="lang-bash"> git push heroku master
</code></pre>
</li>
<li><p>It will take a bit to deploy and install the dependencies on Heroku. </p>
</li>
</ol>
<p>Anytime you need to redeploy the app run</p>
<pre><code class="lang-bash">git add .
git commit -m &quot;new changes&quot;
git push heroku master
</code></pre>
<div class="exercise-end"></div>

<h3 id="deploy-to-azure">Deploy to Azure</h3>
<p>Microsoft has a great article on their Docs site at [<a href="https://docs.microsoft.com/en-us/azure/app-service-web/app-service-web-nodejs-sails">https://docs.microsoft.com/en-us/azure/app-service-web/app-service-web-nodejs-sails</a>]
(<a href="https://docs.microsoft.com/en-us/azure/app-service-web/app-service-web-nodejs-sails">https://docs.microsoft.com/en-us/azure/app-service-web/app-service-web-nodejs-sails</a>)</p>

				</div>
				<hr>
				<div class="chapter">
					<h2 id="cors-configuration">CORS Configuration</h2>
<p>Before we can use our API against a UI or allow others to call the API we need to configure CORS.</p>
<p>CORS allows us to configure which routes, domains, if cookies are passed in, which REST verbs are allowed, and what header values are allowed.  </p>
<p>Without configuring, no one would be able to make calls to our API.</p>
<h3 id="cors-routes">CORS Routes</h3>
<h4 class="exercise-start">
    <b>Exercise</b>: Routes
</h4>

<p>The 1st configuration is the routes that are allowed configuration.  You do not have to allow all Routes and can configure CORS on a per Route basis if you would like.  If I am doing an API that is meant to be called by anyone, I typically set allRoutes to true.</p>
<p>For the purpose of this tutorial, we are going to set it to allow all routes.</p>
<ol>
<li><p>Open config\cors.js</p>
<pre><code class="lang-bash"> cors.js
</code></pre>
</li>
<li><p>Find the commented out allRoutes, uncomment it and set it to true</p>
<pre><code class="lang-javascript"> allRoutes: true,
</code></pre>
</li>
<li><p>Save the file</p>
</li>
</ol>
<div class="exercise-end"></div>

<h3 id="cors-urls-to-allow">CORS URLS to Allow</h3>
<p>You need to specify which URLs are allowed make calls to our API.  It is a comma delimited list of host names beginning with either http:// or https://.  You can also use * to say to allow all domains.  </p>
<p>For the purpose of this tutorial, we are going to allow all domains to make API calls.  This means that any could make a Todo UI and use our API as the backend.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Urls to Allow
</h4>

<ol>
<li><p>Still within the config\cors.js</p>
<pre><code class="lang-bash"> cors.js
</code></pre>
</li>
</ol>
<ol>
<li><p>Find the comment our origin and uncomment it.  </p>
<pre><code class="lang-javascript"> origin: &#39;*&#39;,
</code></pre>
</li>
<li><p>Save the file</p>
</li>
</ol>
<div class="exercise-end"></div>

<h3 id="cors-cookie-sharing">CORS Cookie Sharing</h3>
<p>The ability to share cookies with the API is very important when dealing with in-memory Sails sessions.  By default Sails uses in-memory sessions and sends a cookie with the session hash to the client.  If the client does not send the cookie back with each request then Sails treats the session as a new session which means that for our API, the user would never be treated as being logged in.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Allow Cookies
</h4>

<ol>
<li><p>Within config\cors.js</p>
<pre><code class="lang-bash"> cors.js
</code></pre>
</li>
<li><p>Find the commented out credentials and uncomment it</p>
<pre><code class="lang-javascript"> credentials
</code></pre>
</li>
<li><p>Save the file</p>
</li>
</ol>
<div class="exercise-end"></div>

<h3 id="cors-allowed-rest-verbs">CORS Allowed REST verbs</h3>
<p>As part of the CORS pre-flight checks, it determines if the REST verb is allowed or not.  We are going to define that all REST verbs, options and head are allowed. </p>
<h4 class="exercise-start">
    <b>Exercise</b>: REST Verbs Allowed
</h4>

<ol>
<li><p>Within config\cors.js</p>
<pre><code class="lang-bash"> cors.js
</code></pre>
</li>
<li><p>Find the methods list that is commented out and uncomment it.</p>
<pre><code class="lang-javascript"> methods: &#39;GET, POST, PUT, DELETE, OPTIONS, HEAD&#39;,
</code></pre>
</li>
<li><p>Save the file</p>
</li>
</ol>
<div class="exercise-end"></div>

<h3 id="cors-headers">CORS Headers</h3>
<h4 class="exercise-start">
    <b>Exercise</b>: Headers
</h4>

<ol>
<li><p>Within the config\cors.js</p>
<pre><code class="lang-bash"> cors.js
</code></pre>
</li>
<li><p>Find the commented out headers and uncomment it</p>
<pre><code class="lang-javascript"> headers: &#39;content-type&#39;
</code></pre>
</li>
<li><p>Save the file</p>
</li>
</ol>
<div class="exercise-end"></div>

<h3 id="verifying-cors">Verifying CORS</h3>
<p>Before when you tried to query the API, you got a PreFlight error.  Now if you try to query the API, you will be able to see any machine can query the API.  </p>

				</div>
				<hr>
				<div class="chapter">
					<h2 id="connecting-to-a-data-store">Connecting to A Data Store</h2>
<p>In production, you will want to connect to a real data store instead of the default JSON file data store.</p>
<p>Sails has more than 30 data stores connectors available.</p>
<p>All of the connections are stored in config/connection.js and the default connection to use is stored in config/models.js</p>
<h3 id="assumptions">Assumptions</h3>
<p>It is assume that you already have a database created.  If you do not have a database, you can create a free MongoDb and Postgres on Heroku or a free MySQL database on Azure.  For this tutorial, we are going to use a free Postgresql database hosted on Heroku.</p>
<h3 id="postgres">Postgres</h3>
<h4 class="exercise-start">
    <b>Exercise</b>: Postgres
</h4>

<ol>
<li>Open integrated terminal</li>
<li><p>Run the following npm install command</p>
<pre><code class="lang-bash"> npm install sails-postgresql --save
</code></pre>
</li>
<li><p>Open config\connections.js</p>
<pre><code class="lang-bash"> connections.js
</code></pre>
</li>
<li><p>Find the Postgres section</p>
</li>
<li>Uncomment the somePostgresqlServer connection </li>
<li>Change the name from somePostgresqlServer to sails-ws-pg</li>
<li>Remove the host, user, password, and database for your Postgres database configuration</li>
<li><p>Add url set to process.env.DATABASE_url and ssl = true to the configuration</p>
<pre><code class="lang-javascript"> sailsTutorialPostgres: {
     adapter: &#39;sails-postgresql&#39;,
     url: process.env.DATABASE_URL,
     ssl: true
 }
</code></pre>
</li>
<li>Save the file</li>
</ol>
<div class="exercise-end"></div>

<h3 id="configure-models-to-use-connection">Configure Models to Use Connection</h3>
<p>You have 2 options for configuring the data store connection that models use:</p>
<ol>
<li>Global configuration in config\models.js</li>
<li>Configuration in each model</li>
</ol>
<p>Since we are only using 1 data store for this tutorial, we are going to go with option 1 and create a global configuration.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Configure Model Connection
</h4>

<ol>
<li><p>Open config\models.js</p>
<pre><code class="lang-bash"> models.js
</code></pre>
</li>
<li><p>Uncomment the connection on line 20 </p>
</li>
<li><p>Make sure that line 20 is set to <code>localDiskDb</code></p>
<pre><code class="lang-javascript"> localDiskDb
</code></pre>
</li>
<li><p>Save the file</p>
</li>
</ol>
<p>Next we want to set the development and production environment variables so that we can use the localDiskDb in development and Postgresql in production.</p>
<p>We have 2 environment files:</p>
<ol>
<li>config\env\development.js -&gt; used for development when NODE_ENV is not set to production</li>
<li><p>config\env\production.js -&gt; used for when NODE_ENV is set to production</p>
</li>
<li><p>Open config\env\production.js</p>
</li>
<li><p>Configure the models to use the sailsTutorialPostgres connection that we just configured</p>
<pre><code class="lang-javascript"> models: {
     connection: &#39;sailsTutorialPostgres&#39;
 },
</code></pre>
</li>
<li><p>Restart sails lift and it will connect to your data store.  The first time will be slower as it migrates your models (e.g. creates tables and columns)</p>
</li>
</ol>
<div class="alert alert-warning" role="alert"><strong>Warning</strong>: If you connect to your data store for the first time with the NODE_ENV set to production or run sails lift with the --prod flag, the migrate configuration will automatically be set to safe and your models will not be created in the data store.  To workaround this, you can connect to your data store from your local machine to get the models migrated.  Just becareful doing this since it could potentially impact data and/or performance during the migrate operation</div>

<div class="exercise-end"></div>

<h4 class="exercise-start">
    <b>Exercise</b>: Deploy Changes to Heroku
</h4>

<p>We are now ready to deploy our updates to Heroku.</p>
<ol>
<li>Open the integrated terminal</li>
<li><p>Add our changes to git</p>
<pre><code class="lang-bash"> git add .
</code></pre>
</li>
<li><p>Commit our changes</p>
<pre><code class="lang-bash"> git commit -m &quot;configured postgres&quot;
</code></pre>
</li>
<li><p>Push our changes to Heroku</p>
<pre><code class="lang-bash"> git push heroku master
</code></pre>
</li>
<li><p>You can now access the API at <a href="https://sails-ws.herokuapp.com/">https://sails-ws.herokuapp.com/</a></p>
<ul>
<li>The first thing you will want to do is run a post against <a href="https://sails-ws.herokuapp.com/user">https://sails-ws.herokuapp.com/user</a> to create our new user.  </li>
<li>Then you can make calls against the User and Todo Api</li>
</ul>
</li>
</ol>
<div class="exercise-end"></div>
				</div>
				<hr>
				<div class="chapter">
					<h2 id="hooking-up-a-ui">Hooking Up a UI</h2>
<p>As part of my <a href="http://digitaldrummerj.me/angular-tutorial">Angular Workshop</a>, you build a Todo UI that utilizes the Sails Api that we just built.  The completed code for the UI is available at [<a href="https://github.com/digitaldrummerj/angular-tutorial-code">https://github.com/digitaldrummerj/angular-tutorial-code</a>].</p>
<h3 id="getting-the-code">Getting the Code</h3>
<h4 class="exercise-start">
    <b>Exercise</b>: Getting the Code
</h4>

<ol>
<li>Download the Zip file for the completed code</li>
<li>Unzip the download zip file </li>
</ol>
<div class="exercise-end"></div>

<h3 id="using-the-code">Using the Code</h3>
<p>You need to install the Angular CLI in order to use the code.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Angular CLI Install
</h4>

<div class="alert alert-info" role="alert">If you already have the latest Angular CLI installed, you can skip this step</div>

<ol>
<li>Open a command prompt or terminal</li>
<li><p>Run the following npm command</p>
<pre><code class="lang-bash"> npm install -g @angular/cli
</code></pre>
 <div class="alert alert-warning" role="alert"><strong>Warning</strong>: If you are on a Mac, you may need to run <code>sudo npm install -g @angular/cli</code></div>
</li>
<li><p>Navigate to the directory you unzipped the code into and go into the Angular project directory</p>
</li>
<li><p>Install the npm dependencies</p>
<pre><code class="lang-bash"> npm install
</code></pre>
</li>
<li><p>Open the directory for the Angular code in Visual Studio Code</p>
</li>
<li><p>Open the src/environments/environment.ts file</p>
<pre><code class="lang-bash"> environment.ts
</code></pre>
</li>
<li><p>Change the API base url to your Sails url.  Either your locally running instance or your deployed instance.</p>
</li>
<li>Save the file</li>
<li><p>Start the Angular web server</p>
<pre><code class="lang-bash"> ng serve
</code></pre>
</li>
<li><p>Navigate to <a href="http://localhost:4200">http://localhost:4200</a> to view the UI</p>
</li>
<li>You can now login to the account that you created using Postman or create a new account.</li>
<li>Once you create/login, you will be able to see your todo list on the home page</li>
<li>On the home page, you can add new Todo items, completed an item or delete an item.</li>
</ol>

				</div>
				<!--<hr>
				<div class="chapter">
					<h2 id="unit-testing">Unit Testing</h2>
<p>Coming soon.....</p>

				</div>
				<hr>
				<div class="chapter">
					<h2 id="linting">Linting</h2>
<p>Coming soon...</p>

				</div>-->
				<hr>
				<div class="chapter">
					<h2 id="thank-you">Thank you</h2>
<p>You now have everything that you need to start developing your own Sails based API and deploy it to a production environment.</p>
<p>Thank you for going through this tutorial.</p>
<p>You can follow me on twitter at <a href="https://twitter.com/digitaldrummerj">@digitaldrummerj</a> and on my blog at <a href="http://digitaldrummerj.me/">digitaldrummerj.me</a>.</p>

				</div>
			</div>
		</div>
	</div>

	<script src="scripts/built.js"></script>

</body>

</html>
